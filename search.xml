<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jdk及CGLib代理]]></title>
    <url>%2F20180227%2Fproxy%2F</url>
    <content type="text"><![CDATA[代理：为其他对象提供一种代理以控制对这个对象的访问。 静态代理程序运行前就已经存在的编译好的代理类 假设我们有一个Hello类，其中有一个sayHello的方法，输出一个字符串，代码如下：123456public class Hello&#123; public void sayHello()&#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 现在要在sayHello方法执行前后做些事情，比如各打印一句话，我们可以将上面的程序改成这样：12345678public class Hello&#123; public void sayHello()&#123; System.out.println(&quot;========== begin ==========&quot;); System.out.println(&quot;hello!&quot;); System.out.println(&quot;========== end ==========&quot;); &#125;&#125; 看似完成了效果，但是需要我们修改sayHello方法的代码，有没有办法不修改目标方法呢，我们可以创建一个代理类，如下：12345678910111213141516171819public class HelloProxy&#123; private Hello hello; public HelloProxy(Hello hello)&#123; this.hello = hello; &#125; public void doProxy()&#123; System.out.println(&quot;========== begin ==========&quot;); hello.sayHello(); System.out.println(&quot;========== end ==========&quot;); &#125; public static void main(String [] args) &#123; HelloProxy proxy = new HelloProxy(new Hello()); proxy.doProxy(); &#125;&#125; 但是，如果我们有多个类要实现同样的代理任务，按这种方式我们需要为每个类相应的创建一个XXXProxy代理类，看起来有点傻，有没有其他办法呢？我们可以用Java的动态代理来实现： 动态代理程序运行前并不存在代理类，无需手动编写代理类的源码Java动态代理需要代理类和委托类实现同一个接口,通过Java反射来生成。定义一个目标接口：12345public interface TargetInterface&#123; public void sayHello(); public void sayGoodbye();&#125; 实现目标接口的委托类：12345678910public class TargetImpl implements TargetInterface&#123; public void sayHello()&#123; System.out.println(&quot;========== hello ==========&quot;); &#125; public void sayGoodbye()&#123; System.out.println(&quot;========== goodbye ==========&quot;); &#125;&#125; 最后，代理处理类：123456789101112131415161718192021222324252627282930public class ProxyHandler implements InvocationHandler&#123; private Object target; public ProxyHandler(Object target)&#123; this.target = target; &#125; //实现了InvocationHandler接口，方法调用会被转发到这个方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;========== before ==========&quot;); Object object = method.invoke(target, args); System.out.println(&quot;========== after ==========&quot;); return object; &#125; //获取代理类，*关键 public &lt;T&gt; T getProxy()&#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(),//代理对象的类加载器 target.getClass().getInterfaces(),//代理对象要实现的接口 this);//实际处理程序 &#125; public static void main(String [] args)&#123; TargetInterface target = new ProxyHandler(new TargetImpl()).getProxy(); target.sayHello(); &#125;&#125; 反编译代理类后，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public final class $proxy4 extends Proxy implements TargetInterface&#123; private static Method m3; private static Method m1; private static Method m0; private static Method m4; private static Method m2; public $proxy4(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final void sayHello() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void sayGoodbye() throws &#123; try &#123; this.h.invoke(this, m4, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; //省略来自Object类的hashCode(),equals()以及toString()方法 static &#123; try &#123; m3 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayHello&quot;, new Class[0]); m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m4 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayGoodbye&quot;, new Class[0]); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 前面我们说过Java原生动态代理需要代理类和委托类实现同一接口，那如果是没有接口的类呢？我们可以使用开源的CGLib。用我们之前定义的Hello类，他没有实现任何接口，如下：12345public class Hello&#123; public void sayHello()&#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 代理处理类： 实现MethodInterceptor，方法调用转发到intercept()方法 1234567891011121314151617181920public class ProxyInterceptor implements MethodInterceptor&#123; @Override public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;========== before ==========&quot;); Object object = proxy.invokeSuper(target,args); System.out.println(&quot;========== end ==========&quot;); return object; &#125; public &lt;T&gt; T getProxy(Class&lt;T&gt; cls)&#123; return (T) Enhancer.create(cls,this);//1 父类 2实际处理 &#125; public static void main(String[] args) &#123; ProxyInterceptor proxy = new ProxyInterceptor(); TargetInterface target = proxy.getProxy(Hello.class); target.sayHello(); &#125;&#125; 代理类具体实现（来自网络）：1234567891011121314151617181920212223public class HelloConcrete$$EnhancerByCGLIB$$e3734e52 extends HelloConcrete implements Factory&#123; ... private MethodInterceptor CGLIB$CALLBACK_0; // ~~ ... public final String sayHello(String paramString) &#123; ... MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; // 将请求转发给MethodInterceptor.intercept()方法。 return (String)tmp17_14.intercept(this, CGLIB$sayHello$0$Method, new Object[] &#123; paramString &#125;, CGLIB$sayHello$0$Proxy); &#125; return super.sayHello(paramString); &#125; ...&#125; 总结 使用jdk实现动态代理需要代理类和委托类实现同样的接口。 使用CGLib，用继承实现，不能对final修饰的类及方法使用。 （完）]]></content>
      <tags>
        <tag>CGLib</tag>
        <tag>Proxy</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令之ls]]></title>
    <url>%2F20180111%2Flinux-ls%2F</url>
    <content type="text"><![CDATA[此为Linux命令使用系列记录，博主使用到了哪些命令就写了哪些，命令的参数也记录不全，用到的就写了，需要完整学习，请参考Linux命令大全(手册)_Linux常用命令行实例详解_Linux命令学习手册 作用ls命令用来显示目标列表 语法 ls (选项) (参数) 参数目录：指定要显示列表的目录，也可以是具体的文件。 示例 列出当前目录下非隐藏文件及目录 [root@hostname ~]# ls 列出当前目录下所有文件及目录 [root@hostname ~]# ls -a. .bash_history .bash_profile .cache .npm .pydistutils.cfg .tcshrc.. .bash_logout .bashrc .cshrc .pip .ssh 以长格式列出当前目录下所有文件及目录 [root@hostname ~]# ls -a -ltotal 60dr-xr-x—. 6 root root 4096 Jan 1 09:57 .dr-xr-xr-x. 18 root root 4096 Dec 31 14:45 ..-rw——- 1 root root 1403 Jan 11 09:39 .bash_history… &emsp;&emsp;命令结果解析 按最近一次修改的时间排序显示 [root@hostname ~]# ls -t.bash_history . .. .pydistutils.cfg .bash_logout .bashrc .tcshrc.npm .ssh .pip .cache .bash_profile .cshrc 指定目录显示 [root@hostname tmp]# ls testson test.txt 遍历目录显示 [root@hostname tmp]# ls test -Rtest:son test.txt&emsp;test/son:sontest.txt 选项 -a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；-A：显示除影藏文件“.”和“..”以外的所有文件列表；-C：多列显示输出结果。这是默认选项；-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；-F：在每个输出项后追加文件的类型标识符，具体含义：“”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；–file-type：与“-F”选项的功能相同，但是不显示“”；-k：以KB（千字节）为单位显示文件大小；-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；-m：用“,”号区隔每个文件和目录的名称；-n：以用户识别码和群组识别码替代其名称；-r：以文件名反序排列并输出目录内容列表；-s：显示文件和目录的大小，以区块为单位；-t：用文件和目录的更改时间排序；-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；-R：递归处理，将指定目录下的所有文件及子目录一并处理；–full-time：列出完整的日期与时间；–color[=WHEN]：使用不同的颜色高亮显示不同类型的。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHub Pages搭建个人博客]]></title>
    <url>%2F20171231%2Fhexo-github-pages%2F</url>
    <content type="text"><![CDATA[准备工具 Node.js（必须）用于支持Hexo，生成静态页面 Git（必须）用于推送本地内容 注册一个GitHib账号，存放文件，服务器 搭建环境 Node.jsWindows官网下载.msi文件到本地，双击安装即可 Linux(CentOS)1$ sudo yum install nodejs GitWindows官网下载安装软件包到本地，双击安装即可 Linux(CentOS)1$ yum install git &emsp;教程：Git - Book GitHub（去注册）关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可1$ ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; &emsp;GitHub 配置SSH Key 创建一个仓库做GitHub Pages（What is GitHub Pages?）Note：&emsp;&emsp;1.第一次需要验证邮箱&emsp;&emsp;2.仓库名称固定格式为： 你的GitHub用户名.github.io创建成功后，现在可以访问你的GitHub Pages了 安装Hexo 1$ npm install -g hexo 查看版本1$ hexo -v 创建Hexo目录1$ mkdir Hexo 初始化1$ hexo init [目录名] 或进入目录执行命令 $ hexo init Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍） 安装依赖1npm install 本地预览 生成静态页面和资源文件1$ hexo generate 简写：hexo g 启动服务1$ hexo server 简写：hexo s 命令可以组合使用,启动服务并生成资源文件1$ hexo s -g 更多命令查看Hexo文档 现在你可以通过 http://localhost:4000/ 进行访问了 部署至GitHub 修改Hexo根目录下的 _config.yml 主站配置文件中的 deploy 参数：12345deploy: type: git repo: &lt;仓库地址&gt; branch: [分支名称] message: [提交信息] 部署1$ hexo deploy 简写： hexo d Note:&emsp;&emsp;部署提示找不到：git&emsp;&emsp;3.0 后 type需改为 git ，deploy部分被单独出来了，需要单独安装 安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 执行 hexo d ，部署成功后开始访问你的博客吧！ （完）]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
