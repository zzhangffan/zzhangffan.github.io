<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring事务传播行为]]></title>
    <url>%2F20180303%2Fspring-transcation-propagation-behavior%2F</url>
    <content type="text"><![CDATA[Spring对事务的解决方案，是对 数据库事务 的补充或扩展。它是解决方法间的事务传播。 事务传播行为Spring一共提供了7种事务传播行为：假设事务从方法A传播到了方法B，面对方法B他需要问一个问题：事务A有事务吗？ PROPAGATION_REQUIRED如果没有，就新建一个事务；如果有，就加入当前事务。Spring默认事务传播行为。 PROPAGATION_REQUIRES_NEW如果没有，就新建一个事务；如果有，就将当前事务挂起，创建一个新事物，与原来的事务没有任何关系。 PROPAGATION_NESTED如果没有，就新建一个事务；如果有，就在当前事务中嵌套一个事务。子事务与主事务之间是有关联的，当主事务提交或回滚时，子事务也会提交或回滚。 PROPAGATION_SUPPORTS如果没有，就以非事务方式执行；如果有，已使用当前事务。有就有，没有就没有 PROPAGATION_NOT_SUPPORTED如果没有，就以非事务方式执行；如果有，就将当前事务挂起。没有就算了，有也不支持。 PROPAGATION_NEVER如果没有，就以非事务方式执行；如果有，就抛出异常。没有就算了，有也不支持，不仅不支持我还给你报错 PROPAGATION_MANDATORY如果没有，就抛出异常；如果有，就是用当前事务。必须要有事务 Spring还提供了一些其他功能： 事务超时解决事务时间太久，消耗资源，给事务设置一个最大时长，超过了直接回滚事务。 只读事务忽略哪些不需要事务的方法，提升性能。 Spring事务配置注解式配置123...&lt;tx:annotation-driven transaction-manager=&quot;事务管理器&quot;/&gt;... 在需要事务的方法上使用：1234@Transactionalpublic void xxx() &#123; ...&#125; 事务可配置属性： 事务传播性@Transactional(propagation=Propagation.REQUIRED) 事务的超时性@Transactional(timeout=30) 单位秒 事务的隔离级别@Transactional(isolation=Isolation.READ_COMMITTED) 回滚（指定需要回滚的异常类）@Transactional(rollbackFor={RuntimeException.class,Exception.class}) 只读@Transactional(readOnly=true)… @Transactional 注解定义在类上，对类中所有public方法有效，定义在方法上对被定义方法（public）有效。 XML配置123456789101112...&lt;tx:advice id=&quot;TestAdvice&quot; transaction-manager=&quot;事务管理器&quot;&gt; &lt;!--配置事务传播性，隔离级别以及超时回滚等问题 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Exception&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;... （完）]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F20180303%2Ftransaction%2F</url>
    <content type="text"><![CDATA[什么是事务 事务，一般是指要做的或所做的事情。 数据库事务数据库事务，是指作为单个逻辑工作单元执行的一系列操作,要么完全地执行,要么完全地不执行。 事务的特性： 原子性（基础）事务必须是一个不可分割的整体 一致性（要求）事务（一组操作）完成时，必须让数据具有一致性。例如：你的朋友小明还钱给你，他从他的账上扣了1000，可你的账上并没有加1000块，你肯定认为这笔账没有还。这种情况就是非一致性的。 隔离性（手段）数据库操作之间彼此应该是没有任何干扰的，假设你正在往数据库里查数据，别人正好在删数据，这种情况下你读的数据肯定是有问题的。为了实现操作之间彼此没有干扰，有专家定义了一个规范（事务隔离级别）： READ_UNCOMMITTED; 读未提交，一个事务可以读到另一个事务未提交的数据。 READ_COMMITTED; 读提交，一个事务要等另一个事务提交才能读数据。 REPEATABLE_READ; 重复读，一个事务开启时，其他事务不允许再做修改操作。 SERIALIZABLE; 序列化，事务串行化顺序执行。 持久性（目的）事务一旦提交，数据库的修改应该永久的。还是还钱的例子，小明从他的账上扣了1000，你的账上也加了1000块，转账完成后，在不做其他数据库操作的情况下，这1000块钱应该永远存在你的账户。 事务面临的问题上面说事务的特性时，讲到的事务隔离级别就是为了解决下面的问题： 脏读（读到垃圾数据） 事务A从账户中转出1000元，事务B查询余额为0元，事务A刚才的转账事务，余额恢复为1000元，事务B往里存了1000元，并提交了事务。现在账户中余额为1000元，这肯定是不对的。 脏读：一个事务读到了另一个事务未提交的数据。通过设置数据库隔离级别为 TEAD_COMMITTED 解决。 不可重复读 事务A查询余额为1000元，事务B查询余额为1000元，事务A取出1000元并提交了事务，事务A再次查询余额，余额变成了0元。 不可重复读：一个事读了另一个事务已提交的更新操作。通过设置数据库级别为 REPEATABLE_READ 解决。 幻读 事务B查询班级人数为30人，事务A新增一个同学并提交事务，事务B再次统计人数为31元。事务B很懵逼，这怎么像鬼一样，突然就多出一个人来了。 幻读：一个事务读到另一个事务提交的新增操作。通过设置数据库级别为 SERIALIZABLE 解决。 大多数数据库默认设置 READ_COMMITTED 为默认隔离级别，MySql默认使用 REPEATABLE-READ 为默认隔离级别。 数据库怎么实现隔离的？ Spirng事务支持 （完）]]></content>
  </entry>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F20180301%2Fhash-table%2F</url>
    <content type="text"><![CDATA[了解哈希表前先了解两个数据结构： 数组、链表 数组一组同类型元素的集合，在内存中表现为一片连续的空间，其中每个数据单元占用相等大小的内存空间。因为空间是连续的，所以可以通过地址的偏移（数组下标）来快速访问，但当要新增或删除一个元素时，其后所有元素要进行相应的移动。 图片来自菜鸟教程 链表是一种物理上非连续、非顺序的数据结构。由一系列节点组成，每个节点除了保存自己的数据还保存了一个指向后继节点的引用。这样每个节点就如同一个链子被串起来了。链表无法快速访问，当要访问一个元素的时候，需从链表的头节点开始遍历，直到找到对应的元素或到达链表尾。当修改或新增一个元素时，只需找到这个元素，并修改其相邻节点的相关引用即可。 图片来自百度图片 哈希表哈希表也叫散列表，通过关键字映射到表中的一个位置来访问数据。映射关键字的函数叫散列函数，存放数据的数组叫散列表。 散列位置 = 散列函数(关键字) 散列函数常用设计方式 直接定址法取关键字或关键字的某个线性函数值为散列地址。 数字分析法分析数据去除重复录较高的部分，利用差别比较大的部分来构建散列地址。 平方取中法取关键字平方后的中间几位来作为散列地址 折叠法将关键字分成位数相同的几部分，最后一部分可以不同，然后取这几部分的叠加和（舍去进位）作为散列地址。 除留余数法取关键字被某个不大于表长的数除运算后的余数作为散列地址。 散列地址 = 关键字 MOD 不大于表长的数 随机算法通过随机函数生成散列地址 一个好的散列函数的值应该尽可能平均分布。 散列冲突不管设计多好的散列函数，都可能出现不同的关键字被映射到表中的同一个位置，我们称着中情况为散列冲突。 假设我们的关键字是{47,67,56,16,25,22}，散列算法为h(key) = key mod 6 。当我们计算关键字{47,67,56,16}时都没有问题： 当散列关键字25时发现 25 mod 6 = 1，可索引1已经被占用了，这就出现了散列冲突。解决冲突的方式： 开放定址法（线性探测、二次探测、随机探测）开放定址法指的是当发生散列冲突时，去探测下一个空的散列位置，只要表中还存在空的散列地址，总能找到。 线性探测在出现散列冲突的位置往后一个位置探测，直到遇到空的位置，存入数据。例子中散列关键字25时索引位置1出现了冲突，我们往后一个位置探测，发现位置2也被占用了，继续往后探测，ok，索引3的位置为空，直接占下来。 二次探测考虑一种情况，假设索引3在散列关键字25之前就被占用，表使用图示如下：这种情况下，尽管表中还有可使用的位置，可通过线性探测我们将无法为关键字25找到可以散列的位置。这种情况我们可以使用二次探测，它不只是往后探测，它对冲突位置前后都进行探测，如图示： 随机探测通过一个伪随机函数（结果是可以确定的）生成散列地址。 开放定址可能出现非同义词的冲突。 拉链法与开放地址寻找下一个空的散列地址不同，拉链法通过在原地进行处理，将所有同义词的记录存在一个单链表中，哈希表中值保存单链表的头指针。如图： （完）]]></content>
      <tags>
        <tag>Java</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal分析]]></title>
    <url>%2F20180228%2Fthreadlocal-analyze%2F</url>
    <content type="text"><![CDATA[ThreadLocal 位于java.lang包下，用来为线程提供局部变量。 ThreadLocal用例假设我们有一个序列生成器，用于生成从1开始，自增为1的序列，代码如下：123456789101112131415public class SeqGenerator&#123; private int seq = 0; public int generatorSeq()&#123; seq += 1; return seq; &#125; public static void main(String[] args)&#123; SeqGenerator seqGenerator = new SeqGenerator(); for (int i = 0; i &lt; 3; i++) &#123;//模拟取3次 System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq()); &#125; &#125;&#125; 程序运行结果如下： Thread-0&gt; 1Thread-0&gt; 2Thread-0&gt; 3 单线程情况下没有问题，但如果是多线程情况下跑这个程序，代码如下：1234567891011121314151617181920212223public class SeqGeneratorThread extends Thread&#123; private SeqGenerator seqGenerator; public SeqGeneratorThread(SeqGenerator seqGenerator)&#123; this.seqGenerator = seqGenerator; &#125; @Override public void run()&#123; System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq()); &#125; public static void main(String[] args)&#123; SeqGenerator seqGenerator = new SeqGenerator(); //创建3个线程，分别获取从1开始的序列 SeqGeneratorThread seqGeneratorThread1 = new SeqGeneratorThread(seqGenerator); SeqGeneratorThread seqGeneratorThread2 = new SeqGeneratorThread(seqGenerator); SeqGeneratorThread seqGeneratorThread3 = new SeqGeneratorThread(seqGenerator); seqGenerator1.start(); seqGenerator2.start(); seqGenerator3.start(); &#125;&#125; 程序运行结果如下： Thread-0&gt; 1Thread-1&gt; 2Thread-2&gt; 3 这显然和预期效果不一致，不是说分别获取从1开始的序列吗！可我们看到是多个线程操作结果叠加，这是因为我们多线程操作了同一生成器对象。 ThreadLocal可以解决线程间数据隔离的问题，个人理解：它为每一个使用该变量的线程都保存一份该变量的副本，让线程运行期间都可以独立地操作自己的副本，而不会和其它线程冲突，实现线程间的数据隔离。 使用ThreadLocal改写程序如下：1234567891011121314151617181920212223242526public class SeqGeneratorThread extends Thread&#123; private static ThreadLocal&lt;SeqGenerator&gt; threadLocal = new ThreadLocal&lt;SeqGenerator&gt;()&#123; @Override protected SeqGenerator initialValue()&#123; return new SeqGenerator(); &#125; &#125;; @Override public void run()&#123; for (int i = 0;i &lt; 3; i++) &#123; SeqGenerator seqGenerator = threadLocal.get(); System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq()); &#125; &#125; public static void main(String[] args)&#123; SeqGeneratorThread seqGenerator1 = new SeqGeneratorThread(); SeqGeneratorThread seqGenerator2 = new SeqGeneratorThread(); SeqGeneratorThread seqGenerator3 = new SeqGeneratorThread(); seqGenerator1.start(); seqGenerator2.start(); seqGenerator3.start(); &#125;&#125; 程序运行结果： Thread-0&gt; 1Thread-1&gt; 1Thread-2&gt; 1Thread-1&gt; 2Thread-0&gt; 2Thread-1&gt; 3Thread-2&gt; 2Thread-0&gt; 3Thread-2&gt; 3 通过代码我们看出，我们把SeqGenerator交给了ThreadLocal封装。通过get()方法取出SeqGenerator，每个线程操作的都是属于自己的序列生成器。 ThreadLocal分析 成员属性: 123456789//hash值，在类实例创建时被确定private final int threadLocalHashCode = nextHashCode();//一个提供原子操作的数字类private static AtomicInteger nextHashCode = new AtomicInteger();// hash增量private static final int HASH_INCREMENT = 0x61c88647; nextHashCode(): 123private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; set(T value): 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 首先获取当前线程的ThreadLocalMap（Thread类中定义了一个ThreadLocalMap类型的实例变量threadLocals），Map不为null时，将ThreadLocal实例作为键和变量副本一起作为方法入参进行set操作。123456789//-----class Thread/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;//-----class ThreadLocalThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 线程中的ThreadLocalMap是懒加载的，当需要存副本的时候才会调用createMap()方法。123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; get()：12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 先获取当前线程的ThreadLocalMap，Map非空的情况下，以ThreadLocal实例为key拿到对应的Entry对象。Entry不为空的情况下返回对应value。 当ThreadLocalMap为null或Entry为null时，调用setinitialValue()方法，该方法如下：12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 该方法首先调用initialValue获取初始值，默认返回null，我们可以重写它。123protected T initialValue() &#123; return null;&#125; 而后的操作与set()基本一致。 remove()：12345public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 获取当前线程的ThreadLocalMap，Map非空时，将ThreadLocal实例作为入参传入删除。 以上三个方法内部还是调用的ThreadLocalMap的方法。 ThreadLocalMap分析在分析ThreadLocalMap之前，先了解几个名词： 条目：ThreadLocalMap中保存的Entry实例。 陈旧条目：Entry实例还存在，其中保存的key已被GC回收，其value将永远不能被访问，也无法被GC自动回收，这样的Entry称为陈旧条目。 插槽、槽：散列地址 ThreadLocalMap使用哈希表（建议先阅读这篇博文，再看后面的）来实现，内部使用Entry类来存储数据，Entry使用ThreadLocal实例作为key，变量副本作为value。Entry类定义如下：123456789static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125; 其中存储的对ThreadLocal的引用是一个弱引用。 constructor:123456789101112/** * Construct a new map initially containing (firstKey, firstValue). * ThreadLocalMaps are constructed lazily, so we only create * one when we have at least one entry to put in it. */ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; ThreadLocalMap 有两个构造函数，这里列出了一个，另一个请自行查阅。 INITIAL_CAPACITY = 16 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);，这里实际上是对 INITIAL_CAPACITY - 1 进行了取余操作。之所以能这样取余是因为 INITIAL_CAPACITY 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。 setThreshold()方法设置阈值，threshold = len * 2 / 3 set(ThreadLocal key, Object value): 1234567891011121314151617181920212223242526272829303132333435//设置值private void set(ThreadLocal key, Object value) &#123; //ThreadLocalMap使用Entry保存数据，获得保存所有Entry的数组（散列表） Entry[] tab = table; //表的长度 int len = tab.length; 根据ThreadLocal的哈希值计算散列位置 int i = key.threadLocalHashCode &amp; (len-1); //线性探测 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); //找到同样的键，直接覆盖值 if (k == key) &#123; e.value = value; return; &#125; //键等于null，替换陈旧条目 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; //映射位置没有元素，创建一个Entry初始化 tab[i] = new Entry(key, value); int sz = ++size; //清理一些插槽，如果没有清理，并且数组实际大小大于阈值，调用重新散列的方法 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; replaceStaleEntry(ThreadLocal key, Object value, int staleSlot): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//替换陈旧条目private void replaceStaleEntry(ThreadLocal key, Object value, int staleSlot) &#123; //取得散列表 Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; // 优先往前查找要清除的插槽 for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // 线性查找 for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal k = e.get(); // 找到同样key，交换它们 if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // 未找到其他陈旧条目 if (slotToExpunge == staleSlot) // 将当前位置记录为要清除的插槽 slotToExpunge = i; // 先expungeStaleEntry()清除要清除的插槽 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // 没找到其他陈旧条目 if (k == null &amp;&amp; slotToExpunge == staleSlot) // 记录原本陈旧条目位置为要清除的插槽 slotToExpunge = i; &#125; // 当前失效key没有被其他条目引用，创建一个条目放入插槽 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // 当找到其他陈旧条目时，清理陈旧条目 if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; expungeStaleEntry(int staleSlot): 1234567891011121314151617181920212223242526272829303132333435363738394041//删除陈旧条目private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // 将陈旧条目所在插槽置null tab[staleSlot].value = null; tab[staleSlot] = null; // 修改表条目数量 size--; // 重新散列当前槽到下一个空槽间的条目位置 Entry e; // 下一个空槽 int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal k = e.get(); // 陈旧条目直接删除 if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; // 重新计算散列位置 int h = k.threadLocalHashCode &amp; (len - 1); // 新散列不等于当前位置 if (h != i) &#123; // 清理当前位置 tab[i] = null; // 新散列位置如果已被占用，往后散列（哈希冲突，开放定址法，线性探测） while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; rehash(): 123456789101112//重新散列private void rehash() &#123; // 清理所有陈旧条目，循环调用了expungeStaleEntry() expungeStaleEntries(); // 扩容策略？当表已被使用阈值3/4时，调整表大小为原来的2倍 if (size &gt;= threshold - threshold / 4) // 创建一个大小为原来2倍的数组 // 重新散列表中所有条目 // 重新计算阈值，替换旧表 resize();&#125; getEntry(ThreadLocal key): 12345678private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; 计算关键字的散列位置，根据散列位置取值Entry，找到正确Entry时，直接返回；反之调用直接取值失败的getEntry版本，该方法定义如下：1234567891011121314151617181920//直接取值失败的getEntry版本private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; //不是空槽 while (e != null) &#123; ThreadLocal k = e.get(); // 找到条目，返回（出口） if (k == key) return e; //失效条目，直接清除 if (k == null) expungeStaleEntry(i); else //线性探测 i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; remove(ThreadLocal key):123456789101112131415161718//删除private void remove(ThreadLocal key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); //线性探测 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; //断开ThreadLocal引用 e.clear(); //删除陈旧条目 expungeStaleEntry(i); return; &#125; &#125;&#125; 总结 ThreadLocal作用是提供线程的局部变量。 ThreadLocal中的threadLocalHashCode在类实例被创建时被确定，通过支持原子操作的数字类AtomicInteger来获得。 变量副本实际存放在ThreadLocal的静态内部类ThreadLocalMap中，该类也被作为线程Thread类的一个实例属性定义。 ThreadLocalMap是采用散列表来实现的，他是用开放定址法来解决哈希冲突。 ThreadLocalMap保存的是其静态内部类Entry的实例。通过ThreadLocal的实例属性threadLocalHashCode作为关键字通过一个算法来获得散列地址。 Entry类继承了WeakReference类，它对键保持的是一份弱引用。Entry使用ThreadLocal实例作为key，变量副本作为value。 cleanSomeSlots方法没看明白 （完） 参考博文：【Java 并发】详解 ThreadLocal]]></content>
      <tags>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk及CGLib代理]]></title>
    <url>%2F20180227%2Fproxy%2F</url>
    <content type="text"><![CDATA[代理：为其他对象提供一种代理以控制对这个对象的访问。 静态代理程序运行前就已经存在的编译好的代理类 假设我们有一个Hello类，其中有一个sayHello的方法，输出一个字符串，代码如下：123456public class Hello&#123; public void sayHello()&#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 现在要在sayHello方法执行前后做些事情，比如各打印一句话，我们可以将上面的程序改成这样：12345678public class Hello&#123; public void sayHello()&#123; System.out.println(&quot;========== begin ==========&quot;); System.out.println(&quot;hello!&quot;); System.out.println(&quot;========== end ==========&quot;); &#125;&#125; 看似完成了效果，但是需要我们修改sayHello方法的代码，有没有办法不修改目标方法呢，我们可以创建一个代理类，如下：12345678910111213141516171819public class HelloProxy&#123; private Hello hello; public HelloProxy(Hello hello)&#123; this.hello = hello; &#125; public void doProxy()&#123; System.out.println(&quot;========== begin ==========&quot;); hello.sayHello(); System.out.println(&quot;========== end ==========&quot;); &#125; public static void main(String [] args) &#123; HelloProxy proxy = new HelloProxy(new Hello()); proxy.doProxy(); &#125;&#125; 但是，如果我们有多个类要实现同样的代理任务，按这种方式我们需要为每个类相应的创建一个XXXProxy代理类，看起来有点傻，有没有其他办法呢？我们可以用Java的动态代理来实现： 动态代理程序运行前并不存在代理类，无需手动编写代理类的源码Java动态代理需要代理类和委托类实现同一个接口,通过Java反射来生成。定义一个目标接口：12345public interface TargetInterface&#123; void sayHello(); void sayGoodbye();&#125; 实现目标接口的委托类：12345678910public class TargetImpl implements TargetInterface&#123; public void sayHello()&#123; System.out.println(&quot;========== hello ==========&quot;); &#125; public void sayGoodbye()&#123; System.out.println(&quot;========== goodbye ==========&quot;); &#125;&#125; 最后，代理处理类：123456789101112131415161718192021222324252627282930public class ProxyHandler implements InvocationHandler&#123; private Object target; public ProxyHandler(Object target)&#123; this.target = target; &#125; //实现了InvocationHandler接口，方法调用会被转发到这个方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;========== before ==========&quot;); Object object = method.invoke(target, args); System.out.println(&quot;========== after ==========&quot;); return object; &#125; //获取代理类，*关键 public &lt;T&gt; T getProxy()&#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(),//代理对象的类加载器 target.getClass().getInterfaces(),//代理对象要实现的接口 this);//实际处理程序 &#125; public static void main(String [] args)&#123; TargetInterface target = new ProxyHandler(new TargetImpl()).getProxy(); target.sayHello(); &#125;&#125; 反编译代理类后，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public final class $proxy4 extends Proxy implements TargetInterface&#123; private static Method m3; private static Method m1; private static Method m0; private static Method m4; private static Method m2; public $proxy4(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final void sayHello() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void sayGoodbye() throws &#123; try &#123; this.h.invoke(this, m4, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; //省略来自Object类的hashCode(),equals()以及toString()方法 static &#123; try &#123; m3 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayHello&quot;, new Class[0]); m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m4 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayGoodbye&quot;, new Class[0]); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 前面我们说过Java原生动态代理需要代理类和委托类实现同一接口，那如果是没有接口的类呢？我们可以使用开源的CGLib。用我们之前定义的Hello类，他没有实现任何接口，如下：12345public class Hello&#123; public void sayHello()&#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 代理处理类： 实现MethodInterceptor，方法调用转发到intercept()方法 1234567891011121314151617181920public class ProxyInterceptor implements MethodInterceptor&#123; @Override public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;========== before ==========&quot;); Object object = proxy.invokeSuper(target,args); System.out.println(&quot;========== end ==========&quot;); return object; &#125; public &lt;T&gt; T getProxy(Class&lt;T&gt; cls)&#123; return (T) Enhancer.create(cls,this);//1 父类 2实际处理 &#125; public static void main(String[] args) &#123; ProxyInterceptor proxy = new ProxyInterceptor(); Hello hello = proxy.getProxy(Hello.class); hello.sayHello(); &#125;&#125; 代理类具体实现（来自网络）：1234567891011121314151617181920212223public class Hello$$EnhancerByCGLIB$$e3734e52 extends Hello implements Factory&#123; ... private MethodInterceptor CGLIB$CALLBACK_0; // ~~ ... public final String sayHello(String paramString) &#123; ... MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; // 将请求转发给MethodInterceptor.intercept()方法。 return (String)tmp17_14.intercept(this, CGLIB$sayHello$0$Method, new Object[] &#123; paramString &#125;, CGLIB$sayHello$0$Proxy); &#125; return super.sayHello(paramString); &#125; ...&#125; 总结 使用jdk实现动态代理需要代理类和委托类实现同样的接口。 使用CGLib，用继承实现，不能对final修饰的类及方法使用。 （完）]]></content>
      <tags>
        <tag>CGLib</tag>
        <tag>Proxy</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令之ls]]></title>
    <url>%2F20180111%2Flinux-ls%2F</url>
    <content type="text"><![CDATA[此为Linux命令使用系列记录，博主使用到了哪些命令就写了哪些，命令的参数也记录不全，用到的就写了，需要完整学习，请参考Linux命令大全(手册)_Linux常用命令行实例详解_Linux命令学习手册 作用ls命令用来显示目标列表 语法 ls (选项) (参数) 参数目录：指定要显示列表的目录，也可以是具体的文件。 示例 列出当前目录下非隐藏文件及目录 [root@hostname ~]# ls 列出当前目录下所有文件及目录 [root@hostname ~]# ls -a. .bash_history .bash_profile .cache .npm .pydistutils.cfg .tcshrc.. .bash_logout .bashrc .cshrc .pip .ssh 以长格式列出当前目录下所有文件及目录 [root@hostname ~]# ls -a -ltotal 60dr-xr-x—. 6 root root 4096 Jan 1 09:57 .dr-xr-xr-x. 18 root root 4096 Dec 31 14:45 ..-rw——- 1 root root 1403 Jan 11 09:39 .bash_history… &emsp;&emsp;命令结果解析 按最近一次修改的时间排序显示 [root@hostname ~]# ls -t.bash_history . .. .pydistutils.cfg .bash_logout .bashrc .tcshrc.npm .ssh .pip .cache .bash_profile .cshrc 指定目录显示 [root@hostname tmp]# ls testson test.txt 遍历目录显示 [root@hostname tmp]# ls test -Rtest:son test.txt&emsp;test/son:sontest.txt 选项 -a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；-A：显示除影藏文件“.”和“..”以外的所有文件列表；-C：多列显示输出结果。这是默认选项；-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；-F：在每个输出项后追加文件的类型标识符，具体含义：“”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；–file-type：与“-F”选项的功能相同，但是不显示“”；-k：以KB（千字节）为单位显示文件大小；-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；-m：用“,”号区隔每个文件和目录的名称；-n：以用户识别码和群组识别码替代其名称；-r：以文件名反序排列并输出目录内容列表；-s：显示文件和目录的大小，以区块为单位；-t：用文件和目录的更改时间排序；-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；-R：递归处理，将指定目录下的所有文件及子目录一并处理；–full-time：列出完整的日期与时间；–color[=WHEN]：使用不同的颜色高亮显示不同类型的。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHub Pages搭建个人博客]]></title>
    <url>%2F20171231%2Fhexo-github-pages%2F</url>
    <content type="text"><![CDATA[准备工具 Node.js（必须）用于支持Hexo，生成静态页面 Git（必须）用于推送本地内容 注册一个GitHib账号，存放文件，服务器 搭建环境 Node.jsWindows官网下载.msi文件到本地，双击安装即可 Linux(CentOS)1$ sudo yum install nodejs GitWindows官网下载安装软件包到本地，双击安装即可 Linux(CentOS)1$ yum install git &emsp;教程：Git - Book GitHub（去注册）关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可1$ ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; &emsp;GitHub 配置SSH Key 创建一个仓库做GitHub Pages（What is GitHub Pages?）Note：&emsp;&emsp;1.第一次需要验证邮箱&emsp;&emsp;2.仓库名称固定格式为： 你的GitHub用户名.github.io创建成功后，现在可以访问你的GitHub Pages了 安装Hexo 1$ npm install -g hexo 查看版本1$ hexo -v 创建Hexo目录1$ mkdir Hexo 初始化1$ hexo init [目录名] 或进入目录执行命令 $ hexo init Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍） 安装依赖1npm install 本地预览 生成静态页面和资源文件1$ hexo generate 简写：hexo g 启动服务1$ hexo server 简写：hexo s 命令可以组合使用,启动服务并生成资源文件1$ hexo s -g 更多命令查看Hexo文档 现在你可以通过 http://localhost:4000/ 进行访问了 部署至GitHub 修改Hexo根目录下的 _config.yml 主站配置文件中的 deploy 参数：12345deploy: type: git repo: &lt;仓库地址&gt; branch: [分支名称] message: [提交信息] 部署1$ hexo deploy 简写： hexo d Note:&emsp;&emsp;部署提示找不到：git&emsp;&emsp;3.0 后 type需改为 git ，deploy部分被单独出来了，需要单独安装 安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 执行 hexo d ，部署成功后开始访问你的博客吧！ （完）]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
