<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>排序算法——快速排序</title>
      <link href="/20180307/sortAlgorithm-quickSort/"/>
      <content type="html"><![CDATA[<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 思想：选定一个基准，从待排序序列两侧开始探测</span><br><span class="line">         * 哨兵a：从右往左找一个小于基准的数</span><br><span class="line">         * 哨兵b：从左往右找一个大于基准的数</span><br><span class="line">         * 交换它们，直到两个哨兵相遇，交换基准</span><br><span class="line">         * 现在基准左边的数都小于基准，右边的数都大于基准</span><br><span class="line">         * 递归如此</span><br><span class="line">         */</span><br><span class="line">        int[] needSortArr = &#123;1, 456, 25, 352, 45, 2, 5, 6, 9, 899, 52, 65, 3&#125;;</span><br><span class="line">        quickSort(needSortArr, 0, needSortArr.length - 1);</span><br><span class="line"></span><br><span class="line">        for (int i : needSortArr) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void quickSort(int[] needSortArr, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right)</span><br><span class="line">            return;</span><br><span class="line">        int i = left;</span><br><span class="line">        int j = right;</span><br><span class="line">        //基准</span><br><span class="line">        int datum = needSortArr[left];</span><br><span class="line"></span><br><span class="line">        while (i != j) &#123;</span><br><span class="line"></span><br><span class="line">            //从右往左探测</span><br><span class="line">            while (needSortArr[j] &gt; datum &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            needSortArr[i] = needSortArr[j];</span><br><span class="line">            //反方向</span><br><span class="line">            while (needSortArr[i] &lt; datum &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            needSortArr[j] = needSortArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //基准</span><br><span class="line">        needSortArr[j] = datum;</span><br><span class="line">        //分左右块递归</span><br><span class="line">        quickSort(needSortArr, left, i - 1);</span><br><span class="line">        quickSort(needSortArr, i + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法——冒泡排序</title>
      <link href="/20180307/sortAlgorithm-bubbleSort/"/>
      <content type="html"><![CDATA[<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 思想：依次比较两个相邻的数，让大的往下落，小的往上冒</span><br><span class="line">         */</span><br><span class="line">        int[] needSortArr = &#123;1, 456, 25, 352, 1, 45, 2, 5, 6, 9, 899, 52, 65, 3&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; needSortArr.length - 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; needSortArr.length - 1 - i; j++) &#123;</span><br><span class="line">                if (needSortArr[j] &gt; needSortArr[j + 1]) &#123;</span><br><span class="line">                    int temp = needSortArr[j];</span><br><span class="line">                    needSortArr[j] = needSortArr[j + 1];</span><br><span class="line">                    needSortArr[j + 1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i : needSortArr) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法——简单选择排序</title>
      <link href="/20180307/sortAlgorithm-selectionSort/"/>
      <content type="html"><![CDATA[<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 思想：每趟选择出最小的数放到已有序列的后面</span><br><span class="line">         */</span><br><span class="line">        int[] needSortArr = &#123;1, 456, 25, 352, 1, 45, 2, 5, 6, 9, 899, 52, 65, 3&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; needSortArr.length; i++) &#123;</span><br><span class="line">            int pos = i;</span><br><span class="line">            int j = i + 1;</span><br><span class="line">            for (;j &lt; needSortArr.length; j++) &#123;</span><br><span class="line">                if (needSortArr[j] &lt; needSortArr[pos])</span><br><span class="line">                    pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">            //交换</span><br><span class="line">            int temp = needSortArr[i];</span><br><span class="line">            needSortArr[i] = needSortArr[pos];</span><br><span class="line">            needSortArr[pos] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i : needSortArr) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法——直接插入排序</title>
      <link href="/20180307/sortAlgorithm-insertSort/"/>
      <content type="html"><![CDATA[<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class InsertSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 思想：排序一组数 a[0..n-1]</span><br><span class="line">         *  1.初始a[0]为有序区</span><br><span class="line">         *  2.比较，将a[i]放入有序区</span><br><span class="line">         *  3.直到i = n -1</span><br><span class="line">         */</span><br><span class="line">        int[] needSortArr = &#123;1, 456, 25, 352, 1, 45, 2, 5, 6, 9, 899, 52, 65, 3&#125;;</span><br><span class="line"></span><br><span class="line">        int temp;</span><br><span class="line">        for (int i = 1; i &lt; needSortArr.length; i++) &#123;</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            temp = needSortArr[i];</span><br><span class="line">            for (; j &gt;= 0 &amp;&amp; temp &lt; needSortArr[j]; j--) &#123;</span><br><span class="line">                needSortArr[j + 1] = needSortArr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            needSortArr[j + 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i : needSortArr) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>命令模式</title>
      <link href="/20180306/patterns-command/"/>
      <content type="html"><![CDATA[<blockquote><p>命令模式（行为型模式）：封装命令，将命令的发出者与执行者之间解耦。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>创建命令执行者类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Receiver &#123;</span><br><span class="line"></span><br><span class="line">    public void action() &#123;</span><br><span class="line">        System.out.println(&quot;Receiver::action&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建命令接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line"></span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建实际命令类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private Receiver receiver;</span><br><span class="line"></span><br><span class="line">    public ConcreteCommand(Receiver receiver) &#123;</span><br><span class="line">        this.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建命令发出者类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Invoker &#123;</span><br><span class="line"></span><br><span class="line">    private Command command;</span><br><span class="line"></span><br><span class="line">    public Invoker(Command command) &#123;</span><br><span class="line">        this.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void action() &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CommandTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Receiver receiver = new Receiver();</span><br><span class="line"></span><br><span class="line">        //通过命令将发出者和执行者解耦</span><br><span class="line">        Command cmd = new ConcreteCommand(receiver);</span><br><span class="line"></span><br><span class="line">        Invoker invoker = new Invoker(cmd);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果：</p><blockquote><p>Receiver::action</p></blockquote><p>Process finished with exit code 0</p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> patterns </tag>
            
            <tag> Command </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>责任链模式</title>
      <link href="/20180306/patterns-responsibility-chain/"/>
      <content type="html"><![CDATA[<blockquote><p>责任链模式（行为型模式）：让多个对象都有机会处理请求，将这些对象连成一条链，处理请求时，让请求在这个链上传递，直到链式的摸一个对象处理了这个请求。避免请求的发送者与处理者耦合。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>定义一个日志处理模板类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractLogger &#123;</span><br><span class="line"></span><br><span class="line">    public static int INFO = 1;</span><br><span class="line">    public static int DEBUG = 2;</span><br><span class="line">    public static int ERROR = 3;</span><br><span class="line"></span><br><span class="line">    protected int level;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 保存下一个处理程序引用（一个接一个形成链）</span><br><span class="line">     */</span><br><span class="line">    protected AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">    public void setNextLogger(AbstractLogger nextLogger) &#123;</span><br><span class="line">        this.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 模板处理方法</span><br><span class="line">     */</span><br><span class="line">    public void logMessage(int level, String message) &#123;</span><br><span class="line">        if (this.level &lt;= level) &#123;</span><br><span class="line">        //“钩子”方法</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nextLogger != null) &#123;</span><br><span class="line">            nextLogger.logMessage(level, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract protected void write(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建具体的日志处理类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//文件日志</span><br><span class="line">public class FileLogger extends AbstractLogger &#123;</span><br><span class="line"></span><br><span class="line">    public FileLogger(int level) &#123;</span><br><span class="line">        this.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void write(String message) &#123;</span><br><span class="line">        System.out.println(&quot;File::Logger:&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//错误日志</span><br><span class="line">public class ErrorLogger extends AbstractLogger &#123;</span><br><span class="line"></span><br><span class="line">    public ErrorLogger(int level) &#123;</span><br><span class="line">        this.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void write(String message) &#123;</span><br><span class="line">        System.out.println(&quot;Error Console::Logger:&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//控制台日志</span><br><span class="line">public class ConsoleLogger extends AbstractLogger &#123;</span><br><span class="line"></span><br><span class="line">    public ConsoleLogger(int level) &#123;</span><br><span class="line">        this.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void write(String message) &#123;</span><br><span class="line">        System.out.println(&quot;Standard Console::Logger:&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ResponsibilityChainTest &#123;</span><br><span class="line"></span><br><span class="line">    private static AbstractLogger getChainOfLoggers()&#123;</span><br><span class="line">        AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">        AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">        AbstractLogger consoleLogger = new FileLogger(AbstractLogger.INFO);</span><br><span class="line"></span><br><span class="line">        //串成链  errorLogger =&gt; fileLogger =&gt; consoleLogger</span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"></span><br><span class="line">        return errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取日志执行链</span><br><span class="line">        AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"></span><br><span class="line">        //分别打印不同级别的日志，</span><br><span class="line">        //而不用关注具体的处理程序是哪一个，</span><br><span class="line">        //只管把“打印不同级别日志”这个请求往执行链传就行</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO,&quot;This is an information.&quot;);</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG, &quot;This is an debug level information.&quot;);</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR, &quot;This is an error information.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果：</p><blockquote><p>File::Logger:This is an information.<br>File::Logger:This is an debug level information.<br>File::Logger:This is an debug level information.<br>Error Console::Logger:This is an error information.<br>File::Logger:This is an error information.<br>File::Logger:This is an error information.</p></blockquote><p>Process finished with exit code 0</p><h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>Servlet中Filter、FilterChain<br>…</p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1><blockquote><p>程序例子来自：<a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">菜鸟教程</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> patterns </tag>
            
            <tag> ResponsibilityChain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/20180306/patterns-observer/"/>
      <content type="html"><![CDATA[<blockquote><p>观察者模式（行为型模式）：观察者观察被观察目标类的状态，被观察目标类管理所有观察它的组件，当自身状态发生改变时，通知所有的观察者组件。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>定义被观察目标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Subject &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    private int state;</span><br><span class="line"></span><br><span class="line">    public int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(int state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *添加观察者组件</span><br><span class="line">     */</span><br><span class="line">    public void attach(Observer observer)&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通知所有观察者</span><br><span class="line">     */</span><br><span class="line">    public void notifyAllObservers()&#123;</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个观察者模板，定义一个统一的提供给观察目标实现通知的模板方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Observer &#123;</span><br><span class="line"></span><br><span class="line">    protected Subject subject;</span><br><span class="line">    public abstract void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建多个观察者组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryObserver extends Observer &#123;</span><br><span class="line"></span><br><span class="line">    public BinaryObserver(Subject subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">        this.subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;Binary String:&quot; + Integer.toBinaryString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OctalObserver extends Observer &#123;</span><br><span class="line"></span><br><span class="line">    public OctalObserver(Subject subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">        this.subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;Octal String:&quot; + Integer.toOctalString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HexObserver extends Observer &#123;</span><br><span class="line"></span><br><span class="line">    public HexObserver(Subject subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">        this.subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;Hex String:&quot; + Integer.toHexString(subject.getState()).toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ObserverTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //观察的目标对象</span><br><span class="line">        Subject subject = new Subject();</span><br><span class="line"></span><br><span class="line">        //创建观察者实体</span><br><span class="line">        new HexObserver(subject);</span><br><span class="line">        new OctalObserver(subject);</span><br><span class="line">        new BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">        //验证目标对象状态更改，将通知所有观察者</span><br><span class="line">        System.out.println(&quot;First state change: 15&quot;);</span><br><span class="line">        subject.setState(15);</span><br><span class="line">        System.out.println(&quot;Second state change: 10&quot;);</span><br><span class="line">        subject.setState(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序输出：</p><blockquote><p>First state change: 15<br>Hex String:F<br>Octal String:17<br>Binary String:1111<br>Second state change: 10<br>Hex String:A<br>Octal String:12<br>Binary String:1010</p></blockquote><p>Process finished with exit code 0</p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1><blockquote><p>程序例子来自：<a href="http://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">菜鸟教程</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> patterns </tag>
            
            <tag> Observer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring事务传播行为</title>
      <link href="/20180303/spring-transcation-propagation-behavior/"/>
      <content type="html"><![CDATA[<blockquote><p>Spring对事务的解决方案，是对 <a href="/20180303/transaction/">数据库事务</a> 的补充或扩展。它是解决方法间的事务传播。</p></blockquote><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>Spring一共提供了7种事务传播行为：<br>假设事务从方法A传播到了方法B，面对方法B他需要问一个问题：事务A有事务吗？</p><ol><li>PROPAGATION_REQUIRED<br>如果没有，就新建一个事务；如果有，就加入当前事务。Spring默认事务传播行为。</li><li>PROPAGATION_REQUIRES_NEW<br>如果没有，就新建一个事务；如果有，就将当前事务挂起，创建一个新事物，与原来的事务没有任何关系。</li><li>PROPAGATION_NESTED<br>如果没有，就新建一个事务；如果有，就在当前事务中嵌套一个事务。子事务与主事务之间是有关联的，当主事务提交或回滚时，子事务也会提交或回滚。</li><li>PROPAGATION_SUPPORTS<br>如果没有，就以非事务方式执行；如果有，已使用当前事务。<note>有就有，没有就没有</note></li><li>PROPAGATION_NOT_SUPPORTED<br>如果没有，就以非事务方式执行；如果有，就将当前事务挂起。<note>没有就算了，有也不支持</note>。</li><li>PROPAGATION_NEVER<br>如果没有，就以非事务方式执行；如果有，就抛出异常。<note>没有就算了，有也不支持，不仅不支持我还给你报错</note></li><li>PROPAGATION_MANDATORY<br>如果没有，就抛出异常；如果有，就是用当前事务。<note>必须要有事务</note></li></ol><p>Spring还提供了一些其他功能：</p><ul><li>事务超时<br>解决事务时间太久，消耗资源，给事务设置一个最大时长，超过了直接回滚事务。</li><li>只读事务<br>忽略哪些不需要事务的方法，提升性能。</li></ul><h2 id="Spring事务配置"><a href="#Spring事务配置" class="headerlink" title="Spring事务配置"></a>Spring事务配置</h2><h3 id="注解式配置"><a href="#注解式配置" class="headerlink" title="注解式配置"></a>注解式配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;事务管理器&quot;/&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在需要事务的方法上使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void xxx() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事务可配置属性：</p><ul><li>事务传播性<br><code>@Transactional(propagation=Propagation.REQUIRED)</code></li><li>事务的超时性<br><code>@Transactional(timeout=30)</code> 单位秒</li><li>事务的隔离级别<br><code>@Transactional(isolation=Isolation.READ_COMMITTED)</code></li><li>回滚（指定需要回滚的异常类）<br><code>@Transactional(rollbackFor={RuntimeException.class,Exception.class})</code></li><li>只读<br><code>@Transactional(readOnly=true)</code><br>…</li></ul><note><code>@Transactional</code> 注解定义在类上，对类中所有public方法有效，定义在方法上对被定义方法（public）有效。</note><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;tx:advice id=&quot;TestAdvice&quot; transaction-manager=&quot;事务管理器&quot;&gt;  </span><br><span class="line">    &lt;!--配置事务传播性，隔离级别以及超时回滚等问题 --&gt;  </span><br><span class="line">    &lt;tx:attributes&gt;  </span><br><span class="line">        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;  </span><br><span class="line">        &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; /&gt;  </span><br><span class="line">        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;  </span><br><span class="line">        &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;  </span><br><span class="line">        &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Exception&quot; /&gt;  </span><br><span class="line">    &lt;/tx:attributes&gt;  </span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事务</title>
      <link href="/20180303/transaction/"/>
      <content type="html"><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><blockquote><p>事务，一般是指要做的或所做的事情。</p></blockquote><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>数据库事务，是指作为单个逻辑工作单元执行的一系列操作,要么完全地执行,要么完全地不执行。</p><p>事务的特性：</p><ul><li>原子性（<note>基础</note>）<br>事务必须是一个不可分割的整体</li><li>一致性（<note>要求</note>）<br>事务（一组操作）完成时，必须让数据具有一致性。例如：你的朋友小明还钱给你，他从他的账上扣了1000，可你的账上并没有加1000块，你肯定认为这笔账没有还。这种情况就是非一致性的。</li><li>隔离性（<note>手段</note>）<br>数据库操作之间彼此应该是没有任何干扰的，假设你正在往数据库里查数据，别人正好在删数据，这种情况下你读的数据肯定是有问题的。<br>为了实现操作之间彼此没有干扰，有专家定义了一个规范（事务隔离级别）：</li></ul><ol><li>READ_UNCOMMITTED; 读未提交，一个事务可以读到另一个事务未提交的数据。</li><li>READ_COMMITTED; 读提交，一个事务要等另一个事务提交才能读数据。</li><li>REPEATABLE_READ; 重复读，一个事务开启时，其他事务不允许再做修改操作。</li><li>SERIALIZABLE; 序列化，事务串行化顺序执行。</li></ol><ul><li>持久性（<note>目的</note>）<br>事务一旦提交，数据库的修改应该永久的。还是还钱的例子，小明从他的账上扣了1000，你的账上也加了1000块，转账完成后，在不做其他数据库操作的情况下，这1000块钱应该永远存在你的账户。</li></ul><h2 id="事务面临的问题"><a href="#事务面临的问题" class="headerlink" title="事务面临的问题"></a>事务面临的问题</h2><p>上面说事务的特性时，讲到的事务隔离级别就是为了解决下面的问题：</p><ul><li>脏读（读到垃圾数据）<blockquote><p>事务A从账户中转出1000元，事务B查询余额为0元，事务A刚才的转账事务，余额恢复为1000元，事务B往里存了1000元，并提交了事务。现在账户中余额为1000元，这肯定是不对的。</p></blockquote></li></ul><p>脏读：一个事务读到了另一个事务未提交的数据。通过设置数据库隔离级别为 TEAD_COMMITTED 解决。</p><ul><li>不可重复读<blockquote><p>事务A查询余额为1000元，事务B查询余额为1000元，事务A取出1000元并提交了事务，事务A再次查询余额，余额变成了0元。</p></blockquote></li></ul><p>不可重复读：一个事读了另一个事务已提交的更新操作。通过设置数据库级别为 REPEATABLE_READ 解决。</p><ul><li>幻读<blockquote><p>事务B查询班级人数为30人，事务A新增一个同学并提交事务，事务B再次统计人数为31元。事务B很懵逼，这怎么像鬼一样，突然就多出一个人来了。</p></blockquote></li></ul><p>幻读：一个事务读到另一个事务提交的新增操作。通过设置数据库级别为 SERIALIZABLE 解决。</p><note>大多数数据库默认设置 READ_COMMITTED 为默认隔离级别，MySql默认使用 REPEATABLE-READ 为默认隔离级别。</note><hr><p><a href="https://www.cnblogs.com/wajika/p/6680200.html" target="_blank" rel="noopener">数据库怎么实现隔离的？</a></p><p><a href="/20180303/spring-transcation-propagation-behavior/">Spirng事务支持</a></p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>哈希表</title>
      <link href="/20180301/hash-table/"/>
      <content type="html"><![CDATA[<p>了解哈希表前先了解两个数据结构：</p><h3 id="数组、链表"><a href="#数组、链表" class="headerlink" title="数组、链表"></a>数组、链表</h3><ul><li><p>数组<br>一组同类型元素的集合，在内存中表现为一片连续的空间，其中每个数据单元占用相等大小的内存空间。因为空间是连续的，所以可以通过地址的偏移（数组下标）来快速访问，但当要新增或删除一个元素时，其后所有元素要进行相应的移动。<br><img src="/images/hash-table/array.jpg" alt="array"></p><blockquote><p>图片来自菜鸟教程</p></blockquote></li><li><p>链表<br>是一种物理上非连续、非顺序的数据结构。由一系列节点组成，每个节点除了保存自己的数据还保存了一个指向后继节点的引用。这样每个节点就如同一个链子被串起来了。链表无法快速访问，当要访问一个元素的时候，需从链表的头节点开始遍历，直到找到对应的元素或到达链表尾。当修改或新增一个元素时，只需找到这个元素，并修改其相邻节点的相关引用即可。<br><img src="/images/hash-table/linked-list.jpg" alt="linked-list"></p><blockquote><p>图片来自百度图片</p></blockquote></li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表也叫散列表，通过关键字映射到表中的一个位置来访问数据。映射关键字的函数叫散列函数，存放数据的数组叫散列表。</p><blockquote><p>散列位置 = 散列函数(关键字)</p></blockquote><h3 id="散列函数常用设计方式"><a href="#散列函数常用设计方式" class="headerlink" title="散列函数常用设计方式"></a>散列函数常用设计方式</h3><ol><li>直接定址法<br>取关键字或关键字的某个线性函数值为散列地址。</li><li>数字分析法<br>分析数据去除重复录较高的部分，利用差别比较大的部分来构建散列地址。</li><li>平方取中法<br>取关键字平方后的中间几位来作为散列地址</li><li>折叠法<br>将关键字分成位数相同的几部分，最后一部分可以不同，然后取这几部分的叠加和（舍去进位）作为散列地址。</li><li>除留余数法<br>取关键字被某个不大于表长的数除运算后的余数作为散列地址。<blockquote><p>散列地址 = 关键字 MOD 不大于表长的数</p></blockquote></li><li>随机算法<br>通过随机函数生成散列地址</li></ol><p>一个好的散列函数的值应该尽可能平均分布。</p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>不管设计多好的散列函数，都可能出现不同的关键字被映射到表中的同一个位置，我们称着中情况为散列冲突。</p><p>假设我们的关键字是{47,67,56,16,25,22}，散列算法为<code>h(key) = key mod 6</code> 。当我们计算关键字{47,67,56,16}时都没有问题：<br><img src="/images/hash-table/eg.jpg" alt="eg"></p><p>当散列关键字25时发现 25 mod 6 = 1，可索引1已经被占用了，这就出现了散列冲突。<br>解决冲突的方式：</p><h4 id="开放定址法（线性探测、二次探测、随机探测）"><a href="#开放定址法（线性探测、二次探测、随机探测）" class="headerlink" title="开放定址法（线性探测、二次探测、随机探测）"></a>开放定址法（线性探测、二次探测、随机探测）</h4><p>开放定址法指的是当发生散列冲突时，去探测下一个空的散列位置，只要表中还存在空的散列地址，总能找到。</p><ul><li><p>线性探测<br>在出现散列冲突的位置往后一个位置探测，直到遇到空的位置，存入数据。<br>例子中散列关键字25时索引位置1出现了冲突，我们往后一个位置探测，发现位置2也被占用了，继续往后探测，ok，索引3的位置为空，直接占下来。<br><img src="/images/hash-table/kfdz-xxtc1.jpg" alt="kfdz-xxtc1"></p></li><li><p>二次探测<br>考虑一种情况，假设索引3在散列关键字25之前就被占用，表使用图示如下：<br><img src="/images/hash-table/kfdz-xxtc2.jpg" alt="kfdz-xxtc2"><br>这种情况下，尽管表中还有可使用的位置，可通过线性探测我们将无法为关键字25找到可以散列的位置。<br>这种情况我们可以使用二次探测，它不只是往后探测，它对冲突位置前后都进行探测，如图示：<br><img src="/images/hash-table/kfdz-ectc.jpg" alt="kfdz-ectc"></p></li><li><p>随机探测<br>通过一个伪随机函数（结果是可以确定的）生成散列地址。</p></li></ul><p>开放定址可能出现非同义词的冲突。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>与开放地址寻找下一个空的散列地址不同，拉链法通过在原地进行处理，将所有同义词的记录存在一个单链表中，哈希表中值保存单链表的头指针。如图：<br><img src="/images/hash-table/llf.jpg" alt="llf"></p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> hash-table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal分析</title>
      <link href="/20180228/threadlocal-analyze/"/>
      <content type="html"><![CDATA[<blockquote><p>ThreadLocal 位于java.lang包下，用来为线程提供局部变量。</p></blockquote><h2 id="ThreadLocal用例"><a href="#ThreadLocal用例" class="headerlink" title="ThreadLocal用例"></a>ThreadLocal用例</h2><p>假设我们有一个序列生成器，用于生成从1开始，自增为1的序列，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SeqGenerator&#123;</span><br><span class="line">private int seq = 0;</span><br><span class="line"></span><br><span class="line">public int generatorSeq()&#123;</span><br><span class="line">seq += 1;</span><br><span class="line">return seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">SeqGenerator seqGenerator = new SeqGenerator();</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;//模拟取3次</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果如下：</p><blockquote><p>Thread-0&gt; 1<br>Thread-0&gt; 2<br>Thread-0&gt; 3</p></blockquote><p>单线程情况下没有问题，但如果是多线程情况下跑这个程序，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SeqGeneratorThread extends Thread&#123;</span><br><span class="line">private SeqGenerator seqGenerator;</span><br><span class="line"></span><br><span class="line">public SeqGeneratorThread(SeqGenerator seqGenerator)&#123;</span><br><span class="line">this.seqGenerator = seqGenerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">SeqGenerator seqGenerator = new SeqGenerator();</span><br><span class="line">//创建3个线程，分别获取从1开始的序列</span><br><span class="line">SeqGeneratorThread seqGeneratorThread1 = new SeqGeneratorThread(seqGenerator);</span><br><span class="line">SeqGeneratorThread seqGeneratorThread2 = new SeqGeneratorThread(seqGenerator);</span><br><span class="line">SeqGeneratorThread seqGeneratorThread3 = new SeqGeneratorThread(seqGenerator);</span><br><span class="line">seqGenerator1.start();</span><br><span class="line">seqGenerator2.start();</span><br><span class="line">seqGenerator3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果如下：</p><blockquote><p>Thread-0&gt; 1<br>Thread-1&gt; 2<br>Thread-2&gt; 3</p></blockquote><p>这显然和预期效果不一致，不是说分别获取从1开始的序列吗！可我们看到是多个线程操作结果叠加，这是因为我们多线程操作了同一生成器对象。</p><p>ThreadLocal可以解决线程间数据隔离的问题，<note>个人理解：它为每一个使用该变量的线程都保存一份该变量的副本，让线程运行期间都可以独立地操作自己的副本，而不会和其它线程冲突，实现线程间的数据隔离。</note></p><p>使用ThreadLocal改写程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SeqGeneratorThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SeqGenerator&gt; threadLocal = new ThreadLocal&lt;SeqGenerator&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SeqGenerator initialValue()&#123;</span><br><span class="line">            return new SeqGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0;i &lt; 3; i++) &#123;</span><br><span class="line">            SeqGenerator seqGenerator = threadLocal.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    SeqGeneratorThread seqGenerator1 = new SeqGeneratorThread();</span><br><span class="line">    SeqGeneratorThread seqGenerator2 = new SeqGeneratorThread();</span><br><span class="line">    SeqGeneratorThread seqGenerator3 = new SeqGeneratorThread();</span><br><span class="line">    seqGenerator1.start();</span><br><span class="line">    seqGenerator2.start();</span><br><span class="line">    seqGenerator3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果：</p><blockquote><p>Thread-0&gt; 1<br>Thread-1&gt; 1<br>Thread-2&gt; 1<br>Thread-1&gt; 2<br>Thread-0&gt; 2<br>Thread-1&gt; 3<br>Thread-2&gt; 2<br>Thread-0&gt; 3<br>Thread-2&gt; 3</p></blockquote><p>通过代码我们看出，我们把SeqGenerator交给了ThreadLocal封装。通过get()方法取出SeqGenerator，每个线程操作的都是属于自己的序列生成器。</p><h2 id="ThreadLocal分析"><a href="#ThreadLocal分析" class="headerlink" title="ThreadLocal分析"></a>ThreadLocal分析</h2><ul><li><p><strong>成员属性</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//hash值，在类实例创建时被确定</span><br><span class="line">private final int threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">//一个提供原子操作的数字类</span><br><span class="line">private static AtomicInteger nextHashCode =</span><br><span class="line">    new AtomicInteger();</span><br><span class="line"></span><br><span class="line">// hash增量</span><br><span class="line">private static final int HASH_INCREMENT = 0x61c88647;</span><br></pre></td></tr></table></figure></li><li><p><strong>nextHashCode()</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>set(T value)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>首先获取当前线程的ThreadLocalMap（<note>Thread类中定义了一个ThreadLocalMap类型的实例变量threadLocals</note>），Map不为null时，将ThreadLocal实例作为键和变量副本一起作为方法入参进行set操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//-----class Thread</span><br><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line"></span><br><span class="line">//-----class ThreadLocal</span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程中的ThreadLocalMap是懒加载的，当需要存副本的时候才会调用createMap()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>get()</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null)</span><br><span class="line">            return (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>先获取当前线程的ThreadLocalMap，Map非空的情况下，以ThreadLocal实例为key拿到对应的Entry对象。Entry不为空的情况下返回对应value。</p><p>当ThreadLocalMap为null或Entry为null时，调用setinitialValue()方法，该方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法首先调用initialValue获取初始值，默认返回null，我们可以重写它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而后的操作与set()基本一致。</p><ul><li><strong>remove()</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">if (m != null)</span><br><span class="line">m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>获取当前线程的ThreadLocalMap，Map非空时，将ThreadLocal实例作为入参传入删除。</p><p>以上三个方法内部还是调用的ThreadLocalMap的方法。</p><h2 id="ThreadLocalMap分析"><a href="#ThreadLocalMap分析" class="headerlink" title="ThreadLocalMap分析"></a>ThreadLocalMap分析</h2><p>在分析ThreadLocalMap之前，先了解几个名词：</p><ul><li>条目：ThreadLocalMap中保存的Entry实例。</li><li>陈旧条目：Entry实例还存在，其中保存的key已被GC回收，其value将永远不能被访问，也无法被GC自动回收，这样的Entry称为陈旧条目。</li><li>插槽、槽：散列地址</li></ul><p>ThreadLocalMap使用<a href="/20180301/hash-table/">哈希表</a>（建议先阅读这篇博文，再看后面的）来实现，内部使用Entry类来存储数据，Entry使用ThreadLocal实例作为key，变量副本作为value。Entry类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中存储的对ThreadLocal的引用是一个<note>弱引用</note>。  </p><ul><li><strong>constructor</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Construct a new map initially containing (firstKey, firstValue).</span><br><span class="line"> * ThreadLocalMaps are constructed lazily, so we only create</span><br><span class="line"> * one when we have at least one entry to put in it.</span><br><span class="line"> */</span><br><span class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</span><br><span class="line">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">    size = 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ThreadLocalMap 有两个构造函数，这里列出了一个，另一个请自行查阅。</p><ol><li><code>INITIAL_CAPACITY = 16</code></li><li><code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</code>，这里实际上是对 INITIAL_CAPACITY - 1 进行了取余操作。之所以能这样取余是因为 INITIAL_CAPACITY 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。</li><li>setThreshold()方法设置阈值，<code>threshold = len * 2 / 3</code></li></ol><ul><li><p><strong>set(ThreadLocal key, Object value)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//设置值</span><br><span class="line">private void set(ThreadLocal key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    //ThreadLocalMap使用Entry保存数据，获得保存所有Entry的数组（散列表）</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    //表的长度</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    根据ThreadLocal的哈希值计算散列位置</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">    //线性探测</span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">        //找到同样的键，直接覆盖值</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //键等于null，替换陈旧条目</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //映射位置没有元素，创建一个Entry初始化</span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    //清理一些插槽，如果没有清理，并且数组实际大小大于阈值，调用重新散列的方法</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>replaceStaleEntry(ThreadLocal key, Object value, int staleSlot)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//替换陈旧条目</span><br><span class="line">private void replaceStaleEntry(ThreadLocal key, Object value,</span><br><span class="line">                                       int staleSlot) &#123;</span><br><span class="line">    //取得散列表</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    int slotToExpunge = staleSlot;</span><br><span class="line">    // 优先往前查找要清除的插槽</span><br><span class="line">    for (int i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        if (e.get() == null)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    // 线性查找</span><br><span class="line">    for (int i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">        // 找到同样key，交换它们</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            // 未找到其他陈旧条目</span><br><span class="line">            if (slotToExpunge == staleSlot)</span><br><span class="line">            // 将当前位置记录为要清除的插槽</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            // 先expungeStaleEntry()清除要清除的插槽</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 没找到其他陈旧条目</span><br><span class="line">        if (k == null &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            // 记录原本陈旧条目位置为要清除的插槽</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前失效key没有被其他条目引用，创建一个条目放入插槽</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    tab[staleSlot] = new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    // 当找到其他陈旧条目时，清理陈旧条目</span><br><span class="line">    if (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>expungeStaleEntry(int staleSlot)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//删除陈旧条目</span><br><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line"></span><br><span class="line">    // 将陈旧条目所在插槽置null</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    tab[staleSlot] = null;</span><br><span class="line">    // 修改表条目数量</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    // 重新散列当前槽到下一个空槽间的条目位置</span><br><span class="line">    Entry e;</span><br><span class="line">    // 下一个空槽</span><br><span class="line">    int i;</span><br><span class="line">    for (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        // 陈旧条目直接删除</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            e.value = null;</span><br><span class="line">            tab[i] = null;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 重新计算散列位置</span><br><span class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">            // 新散列不等于当前位置</span><br><span class="line">            if (h != i) &#123;</span><br><span class="line">            // 清理当前位置</span><br><span class="line">                tab[i] = null;</span><br><span class="line"></span><br><span class="line">                // 新散列位置如果已被占用，往后散列（哈希冲突，开放定址法，线性探测）</span><br><span class="line">                while (tab[h] != null)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>rehash()</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//重新散列</span><br><span class="line">private void rehash() &#123;</span><br><span class="line">// 清理所有陈旧条目，循环调用了expungeStaleEntry()</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    // 扩容策略？当表已被使用阈值3/4时，调整表大小为原来的2倍</span><br><span class="line">    if (size &gt;= threshold - threshold / 4)</span><br><span class="line">    // 创建一个大小为原来2倍的数组</span><br><span class="line">    // 重新散列表中所有条目</span><br><span class="line">    // 重新计算阈值，替换旧表</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>getEntry(ThreadLocal key)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>计算关键字的散列位置，根据散列位置取值Entry，找到正确Entry时，直接返回；反之调用直接取值失败的getEntry版本，该方法定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//直接取值失败的getEntry版本</span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    //不是空槽</span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        // 找到条目，返回（出口）</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        //失效条目，直接清除</span><br><span class="line">        if (k == null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        else</span><br><span class="line">        //线性探测</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>remove(ThreadLocal key)</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//删除</span><br><span class="line">private void remove(ThreadLocal key) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    //线性探测</span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        if (e.get() == key) &#123;</span><br><span class="line">        //断开ThreadLocal引用</span><br><span class="line">            e.clear();</span><br><span class="line">            //删除陈旧条目</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>ThreadLocal作用是提供线程的局部变量。</li><li>ThreadLocal中的threadLocalHashCode在类实例被创建时被确定，通过支持原子操作的数字类AtomicInteger来获得。</li><li>变量副本实际存放在ThreadLocal的静态内部类ThreadLocalMap中，该类也被作为线程Thread类的一个实例属性定义。</li><li>ThreadLocalMap是采用散列表来实现的，他是用开放定址法来解决哈希冲突。</li><li>ThreadLocalMap保存的是其静态内部类Entry的实例。通过ThreadLocal的实例属性threadLocalHashCode作为关键字通过一个算法来获得散列地址。</li><li>Entry类继承了WeakReference类，它对键保持的是一份弱引用。Entry使用ThreadLocal实例作为key，变量副本作为value。</li><li><note>cleanSomeSlots方法没看明白</note></li></ol></blockquote><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1><blockquote><p>参考博文：<a href="https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html" target="_blank" rel="noopener">【Java 并发】详解 ThreadLocal</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jdk及CGLib代理</title>
      <link href="/20180227/proxy/"/>
      <content type="html"><![CDATA[<blockquote><p>代理：为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>程序运行前就已经存在的编译好的代理类</p><p>假设我们有一个Hello类，其中有一个sayHello的方法，输出一个字符串，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line"></span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在要在sayHello方法执行前后做些事情，比如各打印一句话，我们可以将上面的程序改成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line"></span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;========== begin ==========&quot;);</span><br><span class="line">System.out.println(&quot;hello!&quot;);</span><br><span class="line">System.out.println(&quot;========== end ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看似完成了效果，但是需要我们修改sayHello方法的代码，有没有办法不修改目标方法呢，我们可以创建一个代理类，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class HelloProxy&#123;</span><br><span class="line"></span><br><span class="line">private Hello hello;</span><br><span class="line"></span><br><span class="line">public HelloProxy(Hello hello)&#123;</span><br><span class="line">this.hello = hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doProxy()&#123;</span><br><span class="line">System.out.println(&quot;========== begin ==========&quot;);</span><br><span class="line">hello.sayHello();</span><br><span class="line">System.out.println(&quot;========== end ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String [] args) &#123;</span><br><span class="line">HelloProxy proxy = new HelloProxy(new Hello());</span><br><span class="line">proxy.doProxy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，如果我们有多个类要实现同样的代理任务，按这种方式我们需要为每个类相应的创建一个XXXProxy代理类，看起来有点傻，有没有其他办法呢？我们可以用Java的动态代理来实现：</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>程序运行前并不存在代理类，无需手动编写代理类的源码<br><span class="note">Java动态代理需要代理类和委托类实现同一个接口,通过Java反射来生成。</span><br>定义一个目标接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface TargetInterface&#123;</span><br><span class="line"></span><br><span class="line">void sayHello();</span><br><span class="line">void sayGoodbye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现目标接口的委托类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TargetImpl implements TargetInterface&#123;</span><br><span class="line"></span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;========== hello ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sayGoodbye()&#123;</span><br><span class="line">System.out.println(&quot;========== goodbye ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，代理处理类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">public ProxyHandler(Object target)&#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现了InvocationHandler接口，方法调用会被转发到这个方法</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;========== before ==========&quot;);</span><br><span class="line">Object object = method.invoke(target, args);</span><br><span class="line">System.out.println(&quot;========== after ==========&quot;);  </span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取代理类，*关键</span><br><span class="line">public &lt;T&gt; T getProxy()&#123;</span><br><span class="line">return (T) Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),//代理对象的类加载器</span><br><span class="line">target.getClass().getInterfaces(),//代理对象要实现的接口</span><br><span class="line">this);//实际处理程序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String [] args)&#123;</span><br><span class="line">TargetInterface target = new ProxyHandler(new TargetImpl()).getProxy();</span><br><span class="line">target.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译代理类后，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public final class $proxy4</span><br><span class="line">  extends Proxy</span><br><span class="line">  implements TargetInterface</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m0;</span><br><span class="line">  private static Method m4;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  </span><br><span class="line">  public $proxy4(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final void sayHello()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m3, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  public final void sayGoodbye()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m4, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //省略来自Object类的hashCode(),equals()以及toString()方法</span><br><span class="line">  </span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m3 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayHello&quot;, new Class[0]);</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      m4 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayGoodbye&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面我们说过Java原生动态代理需要代理类和委托类实现同一接口，那如果是没有接口的类呢？<br>我们可以使用开源的CGLib。<br>用我们之前定义的Hello类，他没有实现任何接口，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理处理类：</p><ul><li>实现MethodInterceptor，方法调用转发到intercept()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyInterceptor implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;========== before ==========&quot;);</span><br><span class="line">Object object = proxy.invokeSuper(target,args);</span><br><span class="line">System.out.println(&quot;========== end ==========&quot;);</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getProxy(Class&lt;T&gt; cls)&#123;</span><br><span class="line">return (T) Enhancer.create(cls,this);//1 父类 2实际处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ProxyInterceptor proxy = new ProxyInterceptor();</span><br><span class="line">Hello hello = proxy.getProxy(Hello.class);</span><br><span class="line">hello.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类具体实现（来自网络）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Hello$$EnhancerByCGLIB$$e3734e52</span><br><span class="line">  extends Hello</span><br><span class="line">  implements Factory</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  private MethodInterceptor CGLIB$CALLBACK_0; // ~~</span><br><span class="line">  ...</span><br><span class="line">   </span><br><span class="line">  public final String sayHello(String paramString)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0;</span><br><span class="line">    if (tmp17_14 != null) &#123;</span><br><span class="line">      // 将请求转发给MethodInterceptor.intercept()方法。</span><br><span class="line">      return (String)tmp17_14.intercept(this, </span><br><span class="line">              CGLIB$sayHello$0$Method, </span><br><span class="line">              new Object[] &#123; paramString &#125;, </span><br><span class="line">              CGLIB$sayHello$0$Proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.sayHello(paramString);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用jdk实现动态代理需要代理类和委托类实现同样的接口。</li><li>使用CGLib，用继承实现，不能对final修饰的类及方法使用。</li></ul><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> CGLib </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux命令之ls</title>
      <link href="/20180111/linux-ls/"/>
      <content type="html"><![CDATA[<blockquote><p>此为Linux命令使用系列记录，博主使用到了哪些命令就写了哪些，命令的参数也记录不全，用到的就写了，需要完整学习，请参考<a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全(手册)_Linux常用命令行实例详解_Linux命令学习手册</a>    </p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>ls命令用来显示目标列表</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>ls  (选项)  (参数)</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>目录：指定要显示列表的目录，也可以是具体的文件。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li><p><strong><em>列出当前目录下非隐藏文件及目录</em></strong></p><blockquote><p>[root@hostname ~]#  ls</p></blockquote></li><li><p><strong><em>列出当前目录下所有文件及目录</em></strong></p><blockquote><p>[root@hostname ~]#  ls  -a<br>.   .bash_history  .bash_profile  .cache  .npm  .pydistutils.cfg  .tcshrc<br>..  .bash_logout   .bashrc        .cshrc  .pip  .ssh</p></blockquote></li><li><p><strong><em>以长格式列出当前目录下所有文件及目录</em></strong></p><blockquote><p>[root@hostname ~]# ls -a -l<br>total 60<br>dr-xr-x—.   6 root root  4096 Jan  1 09:57 .<br>dr-xr-xr-x.  18 root root  4096 Dec 31 14:45 ..<br>-rw——-    1 root root  1403 Jan 11 09:39 .bash_history<br>…</p></blockquote></li></ul><p>&emsp;&emsp;<a href="/post_sources/linuxcommands/ls-result.xml">命令结果解析</a></p><ul><li><p><strong><em>按最近一次修改的时间排序显示</em></strong></p><blockquote><p>[root@hostname ~]#  ls  -t<br>.bash_history  .     ..    .pydistutils.cfg  .bash_logout   .bashrc  .tcshrc<br>.npm           .ssh  .pip  .cache            .bash_profile  .cshrc</p></blockquote></li><li><p><strong><em>指定目录显示</em></strong></p><blockquote><p>[root@hostname tmp]#  ls  test<br>son  test.txt</p></blockquote></li><li><p><strong><em>遍历目录显示</em></strong></p><blockquote><p>[root@hostname tmp]#  ls  test -R<br>test:<br>son  test.txt<br>&emsp;<br>test/son:<br>sontest.txt</p></blockquote></li></ul><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a><strong>选项</strong></h2><blockquote><p>-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；<br>-A：显示除影藏文件“.”和“..”以外的所有文件列表；<br>-C：多列显示输出结果。这是默认选项；<br>-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；<br>-F：在每个输出项后追加文件的类型标识符，具体含义：“<em>”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；<br>-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；<br>-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；<br>-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；<br>-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；<br>-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；<br>–file-type：与“-F”选项的功能相同，但是不显示“</em>”；<br>-k：以KB（千字节）为单位显示文件大小；<br>-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；<br>-m：用“,”号区隔每个文件和目录的名称；<br>-n：以用户识别码和群组识别码替代其名称；<br>-r：以文件名反序排列并输出目录内容列表；<br>-s：显示文件和目录的大小，以区块为单位；<br>-t：用文件和目录的更改时间排序；<br>-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；<br>-R：递归处理，将指定目录下的所有文件及子目录一并处理；<br>–full-time：列出完整的日期与时间；<br>–color[=WHEN]：使用不同的颜色高亮显示不同类型的。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo + GitHub Pages搭建个人博客</title>
      <link href="/20171231/hexo-github-pages/"/>
      <content type="html"><![CDATA[<blockquote><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2></blockquote><ul><li>Node.js（必须）用于支持Hexo，生成静态页面</li><li>Git（必须）用于推送本地内容</li><li>注册一个GitHib账号，存放文件，服务器</li></ul><blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2></blockquote><ul><li><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><em>Node.js</em></h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><em>Windows</em></h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载.msi文件到本地，双击安装即可</p><h3 id="Linux-CentOS"><a href="#Linux-CentOS" class="headerlink" title="Linux(CentOS)"></a><em>Linux(CentOS)</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install nodejs</span><br></pre></td></tr></table></figure></li><li><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a><em>Git</em></h2><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a><em>Windows</em></h3><p><a href="https://git-scm.com/" target="_blank" rel="noopener">官网</a>下载安装软件包到本地，双击安装即可</p><h3 id="Linux-CentOS-1"><a href="#Linux-CentOS-1" class="headerlink" title="Linux(CentOS)"></a><em>Linux(CentOS)</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install git</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;<strong><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">教程：Git - Book</a></strong></p><ul><li><h2 id="GitHub（去注册）"><a href="#GitHub（去注册）" class="headerlink" title="GitHub（去注册）"></a><em>GitHub</em>（<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">去注册</a>）</h2><h3 id="关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可"><a href="#关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可" class="headerlink" title="关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可"></a>关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;<strong><a href="https://github.com/settings/keys" target="_blank" rel="noopener">GitHub 配置SSH Key</a></strong></p><ul><li><h2 id="创建一个仓库做GitHub-Pages（What-is-GitHub-Pages-）"><a href="#创建一个仓库做GitHub-Pages（What-is-GitHub-Pages-）" class="headerlink" title="创建一个仓库做GitHub Pages（What is GitHub Pages?）"></a><em>创建一个仓库做GitHub Pages（<a href="https://help.github.com/articles/what-is-github-pages/" target="_blank" rel="noopener">What is GitHub Pages?</a>）</em></h2><h3 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h3>&emsp;&emsp;<span class="note"><em>1.第一次需要验证邮箱</em><br>&emsp;&emsp;<em>2.仓库名称固定格式为： 你的GitHub用户名.github.io</em></span><h3 id="创建成功后，现在可以访问你的GitHub-Pages了"><a href="#创建成功后，现在可以访问你的GitHub-Pages了" class="headerlink" title="创建成功后，现在可以访问你的GitHub Pages了"></a>创建成功后，现在可以访问你的GitHub Pages了</h3><img src="/images/hexo-github-pages/call-github-pages.png" alt="call-github-pages.png"></li></ul><blockquote><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/see-hexo-version.png" alt="see-hexo-version.png"></p><h3 id="创建Hexo目录"><a href="#创建Hexo目录" class="headerlink" title="创建Hexo目录"></a>创建Hexo目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir Hexo</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [目录名] 或进入目录执行命令 $ hexo init</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/hexo-init.png" alt="hexo-init.png"></p><h3 id="Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍）"><a href="#Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍）" class="headerlink" title="Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍）"></a>Hexo会自动在这个目录下建立需要的文件夹和文件（<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">目录介绍</a>）</h3><p><img src="/images/hexo-github-pages/hexo-dir.png" alt="hexo-dir.png"></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/npm-install.png" alt="npm-install.png"></p><blockquote><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2></blockquote><h3 id="生成静态页面和资源文件"><a href="#生成静态页面和资源文件" class="headerlink" title="生成静态页面和资源文件"></a>生成静态页面和资源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate简写：hexo g</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server简写：hexo s</span><br></pre></td></tr></table></figure><h3 id="命令可以组合使用-启动服务并生成资源文件"><a href="#命令可以组合使用-启动服务并生成资源文件" class="headerlink" title="命令可以组合使用,启动服务并生成资源文件"></a>命令可以组合使用,启动服务并生成资源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s -g</span><br></pre></td></tr></table></figure><p><strong><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">更多命令查看Hexo文档</a></strong></p><h3 id="现在你可以通过-http-localhost-4000-进行访问了"><a href="#现在你可以通过-http-localhost-4000-进行访问了" class="headerlink" title="现在你可以通过 http://localhost:4000/ 进行访问了"></a>现在你可以通过 <code>http://localhost:4000/</code> 进行访问了</h3><p><img src="/images/hexo-github-pages/hexo-index.png" alt="hexo-index.png"></p><blockquote><h2 id="部署至GitHub"><a href="#部署至GitHub" class="headerlink" title="部署至GitHub"></a>部署至GitHub</h2></blockquote><h3 id="修改Hexo根目录下的-config-yml-主站配置文件中的-deploy-参数："><a href="#修改Hexo根目录下的-config-yml-主站配置文件中的-deploy-参数：" class="headerlink" title="修改Hexo根目录下的 _config.yml 主站配置文件中的 deploy 参数："></a>修改Hexo根目录下的 <code>_config.yml</code> 主站配置文件中的 <code>deploy</code> 参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: &lt;仓库地址&gt;</span><br><span class="line">   branch: [分支名称]</span><br><span class="line">   message: [提交信息]</span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy 简写： hexo d</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/hexo-d.png" alt="hexo-d.png"></p><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>&emsp;&emsp;<span class="note"><em>部署提示找不到：git<br>&emsp;&emsp;3.0 后 type需改为 git ，deploy部分被单独出来了，需要单独安装</em></span></p><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="执行-hexo-d-，部署成功后开始访问你的博客吧！"><a href="#执行-hexo-d-，部署成功后开始访问你的博客吧！" class="headerlink" title="执行 hexo d ，部署成功后开始访问你的博客吧！"></a>执行 <code>hexo d</code> ，部署成功后开始访问你的博客吧！</h3><p><img src="/images/hexo-github-pages/github-pages-index.png" alt="github-pages-index.png"></p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
