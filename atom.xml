<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张帆</title>
  
  <subtitle>做一件有价值的事，一直做，然后等待时间的回报。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="zzhangffan.com/"/>
  <updated>2018-03-03T04:14:23.916Z</updated>
  <id>zzhangffan.com/</id>
  
  <author>
    <name>zhangfan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希表</title>
    <link href="zzhangffan.com/20180301/hash-table/"/>
    <id>zzhangffan.com/20180301/hash-table/</id>
    <published>2018-03-01T00:54:00.000Z</published>
    <updated>2018-03-03T04:14:23.916Z</updated>
    
    <content type="html"><![CDATA[<p>了解哈希表前先了解两个数据结构：</p><h3 id="数组、链表"><a href="#数组、链表" class="headerlink" title="数组、链表"></a>数组、链表</h3><ul><li><p>数组<br>一组同类型元素的集合，在内存中表现为一片连续的空间，其中每个数据单元占用相等大小的内存空间。因为空间是连续的，所以可以通过地址的偏移（数组下标）来快速访问，但当要新增或删除一个元素时，其后所有元素要进行相应的移动。<br><img src="/images/hash-table/array.jpg" alt="array"></p><blockquote><p>图片来自菜鸟教程</p></blockquote></li><li><p>链表<br>是一种物理上非连续、非顺序的数据结构。由一系列节点组成，每个节点除了保存自己的数据还保存了一个指向后继节点的引用。这样每个节点就如同一个链子被串起来了。链表无法快速访问，当要访问一个元素的时候，需从链表的头节点开始遍历，直到找到对应的元素或到达链表尾。当修改或新增一个元素时，只需找到这个元素，并修改其相邻节点的相关引用即可。<br><img src="/images/hash-table/linked-list.jpg" alt="linked-list"></p><blockquote><p>图片来自百度图片</p></blockquote></li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表也叫散列表，通过关键字映射到表中的一个位置来访问数据。映射关键字的函数叫散列函数，存放数据的数组叫散列表。</p><blockquote><p>散列位置 = 散列函数(关键字)</p></blockquote><h3 id="散列函数常用设计方式"><a href="#散列函数常用设计方式" class="headerlink" title="散列函数常用设计方式"></a>散列函数常用设计方式</h3><ol><li>直接定址法<br>取关键字或关键字的某个线性函数值为散列地址。</li><li>数字分析法<br>分析数据去除重复录较高的部分，利用差别比较大的部分来构建散列地址。</li><li>平方取中法<br>取关键字平方后的中间几位来作为散列地址</li><li>折叠法<br>将关键字分成位数相同的几部分，最后一部分可以不同，然后取这几部分的叠加和（舍去进位）作为散列地址。</li><li>除留余数法<br>取关键字被某个不大于表长的数除运算后的余数作为散列地址。<blockquote><p>散列地址 = 关键字 MOD 不大于表长的数</p></blockquote></li><li>随机算法<br>通过随机函数生成散列地址</li></ol><p>一个好的散列函数的值应该尽可能平均分布。</p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>不管设计多好的散列函数，都可能出现不同的关键字被映射到表中的同一个位置，我们称着中情况为散列冲突。</p><p>假设我们的关键字是{47,67,56,16,25,22}，散列算法为<code>h(key) = key mod 6</code> 。当我们计算关键字{47,67,56,16}时都没有问题：<br><img src="/images/hash-table/eg.jpg" alt="eg"></p><p>当散列关键字25时发现 25 mod 6 = 1，可索引1已经被占用了，这就出现了散列冲突。<br>解决冲突的方式：</p><h4 id="开放定址法（线性探测、二次探测、随机探测）"><a href="#开放定址法（线性探测、二次探测、随机探测）" class="headerlink" title="开放定址法（线性探测、二次探测、随机探测）"></a>开放定址法（线性探测、二次探测、随机探测）</h4><p>开放定址法指的是当发生散列冲突时，去探测下一个空的散列位置，只要表中还存在空的散列地址，总能找到。</p><ul><li><p>线性探测<br>在出现散列冲突的位置往后一个位置探测，直到遇到空的位置，存入数据。<br>例子中散列关键字25时索引位置1出现了冲突，我们往后一个位置探测，发现位置2也被占用了，继续往后探测，ok，索引3的位置为空，直接占下来。<br><img src="/images/hash-table/kfdz-xxtc1.jpg" alt="kfdz-xxtc1"></p></li><li><p>二次探测<br>考虑一种情况，假设索引3在散列关键字25之前就被占用，表使用图示如下：<br><img src="/images/hash-table/kfdz-xxtc2.jpg" alt="kfdz-xxtc2"><br>这种情况下，尽管表中还有可使用的位置，可通过线性探测我们将无法为关键字25找到可以散列的位置。<br>这种情况我们可以使用二次探测，它不只是往后探测，它对冲突位置前后都进行探测，如图示：<br><img src="/images/hash-table/kfdz-ectc.jpg" alt="kfdz-ectc"></p></li><li><p>随机探测<br>通过一个伪随机函数（结果是可以确定的）生成散列地址。</p></li></ul><p>开放定址可能出现非同义词的冲突。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>与开放地址寻找下一个空的散列地址不同，拉链法通过在原地进行处理，将所有同义词的记录存在一个单链表中，哈希表中值保存单链表的头指针。如图：<br><img src="/images/hash-table/llf.jpg" alt="llf"></p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解哈希表前先了解两个数据结构：&lt;/p&gt;
&lt;h3 id=&quot;数组、链表&quot;&gt;&lt;a href=&quot;#数组、链表&quot; class=&quot;headerlink&quot; title=&quot;数组、链表&quot;&gt;&lt;/a&gt;数组、链表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组&lt;br&gt;一组同类型元素的集合，在内存中表现为一
      
    
    </summary>
    
    
      <category term="Java" scheme="zzhangffan.com/tags/Java/"/>
    
      <category term="hash-table" scheme="zzhangffan.com/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal分析</title>
    <link href="zzhangffan.com/20180228/threadlocal-analyze/"/>
    <id>zzhangffan.com/20180228/threadlocal-analyze/</id>
    <published>2018-02-28T05:00:28.000Z</published>
    <updated>2018-03-03T04:10:54.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ThreadLocal 位于java.lang包下，用来为线程提供局部变量。</p></blockquote><h2 id="ThreadLocal用例"><a href="#ThreadLocal用例" class="headerlink" title="ThreadLocal用例"></a>ThreadLocal用例</h2><p>假设我们有一个序列生成器，用于生成从1开始，自增为1的序列，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SeqGenerator&#123;</span><br><span class="line">private int seq = 0;</span><br><span class="line"></span><br><span class="line">public int generatorSeq()&#123;</span><br><span class="line">seq += 1;</span><br><span class="line">return seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">SeqGenerator seqGenerator = new SeqGenerator();</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;//模拟取3次</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果如下：</p><blockquote><p>Thread-0&gt; 1<br>Thread-0&gt; 2<br>Thread-0&gt; 3</p></blockquote><p>单线程情况下没有问题，但如果是多线程情况下跑这个程序，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SeqGeneratorThread extends Thread&#123;</span><br><span class="line">private SeqGenerator seqGenerator;</span><br><span class="line"></span><br><span class="line">public SeqGeneratorThread(SeqGenerator seqGenerator)&#123;</span><br><span class="line">this.seqGenerator = seqGenerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">SeqGenerator seqGenerator = new SeqGenerator();</span><br><span class="line">//创建3个线程，分别获取从1开始的序列</span><br><span class="line">SeqGeneratorThread seqGeneratorThread1 = new SeqGeneratorThread(seqGenerator);</span><br><span class="line">SeqGeneratorThread seqGeneratorThread2 = new SeqGeneratorThread(seqGenerator);</span><br><span class="line">SeqGeneratorThread seqGeneratorThread3 = new SeqGeneratorThread(seqGenerator);</span><br><span class="line">seqGenerator1.start();</span><br><span class="line">seqGenerator2.start();</span><br><span class="line">seqGenerator3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果如下：</p><blockquote><p>Thread-0&gt; 1<br>Thread-1&gt; 2<br>Thread-2&gt; 3</p></blockquote><p>这显然和预期效果不一致，不是说分别获取从1开始的序列吗！可我们看到是多个线程操作结果叠加，这是因为我们多线程操作了同一生成器对象。</p><p>ThreadLocal可以解决线程间数据隔离的问题，<note>个人理解：它为每一个使用该变量的线程都保存一份该变量的副本，让线程运行期间都可以独立地操作自己的副本，而不会和其它线程冲突，实现线程间的数据隔离。</note></p><p>使用ThreadLocal改写程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SeqGeneratorThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SeqGenerator&gt; threadLocal = new ThreadLocal&lt;SeqGenerator&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SeqGenerator initialValue()&#123;</span><br><span class="line">            return new SeqGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0;i &lt; 3; i++) &#123;</span><br><span class="line">            SeqGenerator seqGenerator = threadLocal.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;&gt; &quot; + seqGenerator.generatorSeq());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    SeqGeneratorThread seqGenerator1 = new SeqGeneratorThread();</span><br><span class="line">    SeqGeneratorThread seqGenerator2 = new SeqGeneratorThread();</span><br><span class="line">    SeqGeneratorThread seqGenerator3 = new SeqGeneratorThread();</span><br><span class="line">    seqGenerator1.start();</span><br><span class="line">    seqGenerator2.start();</span><br><span class="line">    seqGenerator3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果：</p><blockquote><p>Thread-0&gt; 1<br>Thread-1&gt; 1<br>Thread-2&gt; 1<br>Thread-1&gt; 2<br>Thread-0&gt; 2<br>Thread-1&gt; 3<br>Thread-2&gt; 2<br>Thread-0&gt; 3<br>Thread-2&gt; 3</p></blockquote><p>通过代码我们看出，我们把SeqGenerator交给了ThreadLocal封装。通过get()方法取出SeqGenerator，每个线程操作的都是属于自己的序列生成器。</p><h2 id="ThreadLocal分析"><a href="#ThreadLocal分析" class="headerlink" title="ThreadLocal分析"></a>ThreadLocal分析</h2><ul><li><p><strong>成员属性</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//hash值，在类实例创建时被确定</span><br><span class="line">private final int threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">//一个提供原子操作的数字类</span><br><span class="line">private static AtomicInteger nextHashCode =</span><br><span class="line">    new AtomicInteger();</span><br><span class="line"></span><br><span class="line">// hash增量</span><br><span class="line">private static final int HASH_INCREMENT = 0x61c88647;</span><br></pre></td></tr></table></figure></li><li><p><strong>nextHashCode()</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>set(T value)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>首先获取当前线程的ThreadLocalMap（<note>Thread类中定义了一个ThreadLocalMap类型的实例变量threadLocals</note>），Map不为null时，将ThreadLocal实例作为键和变量副本一起作为方法入参进行set操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//-----class Thread</span><br><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line"></span><br><span class="line">//-----class ThreadLocal</span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程中的ThreadLocalMap是懒加载的，当需要存副本的时候才会调用createMap()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>get()</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null)</span><br><span class="line">            return (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>先获取当前线程的ThreadLocalMap，Map非空的情况下，以ThreadLocal实例为key拿到对应的Entry对象。Entry不为空的情况下返回对应value。</p><p>当ThreadLocalMap为null或Entry为null时，调用setinitialValue()方法，该方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法首先调用initialValue获取初始值，默认返回null，我们可以重写它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而后的操作与set()基本一致。</p><ul><li><strong>remove()</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">if (m != null)</span><br><span class="line">m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>获取当前线程的ThreadLocalMap，Map非空时，将ThreadLocal实例作为入参传入删除。</p><p>以上三个方法内部还是调用的ThreadLocalMap的方法。</p><h2 id="ThreadLocalMap分析"><a href="#ThreadLocalMap分析" class="headerlink" title="ThreadLocalMap分析"></a>ThreadLocalMap分析</h2><p>在分析ThreadLocalMap之前，先了解几个名词：</p><ul><li>条目：ThreadLocalMap中保存的Entry实例。</li><li>陈旧条目：Entry实例还存在，其中保存的key已被GC回收，其value将永远不能被访问，也无法被GC自动回收，这样的Entry称为陈旧条目。</li><li>插槽、槽：散列地址</li></ul><p>ThreadLocalMap使用<a href="/20180301/hash-table/">哈希表</a>（建议先阅读这篇博文，再看后面的）来实现，内部使用Entry类来存储数据，Entry使用ThreadLocal实例作为key，变量副本作为value。Entry类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中存储的对ThreadLocal的引用是一个<note>弱引用</note>。  </p><ul><li><strong>constructor</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Construct a new map initially containing (firstKey, firstValue).</span><br><span class="line"> * ThreadLocalMaps are constructed lazily, so we only create</span><br><span class="line"> * one when we have at least one entry to put in it.</span><br><span class="line"> */</span><br><span class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</span><br><span class="line">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">    size = 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ThreadLocalMap 有两个构造函数，这里列出了一个，另一个请自行查阅。</p><ol><li><code>INITIAL_CAPACITY = 16</code></li><li><code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</code>，这里实际上是对 INITIAL_CAPACITY - 1 进行了取余操作。之所以能这样取余是因为 INITIAL_CAPACITY 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。</li><li>setThreshold()方法设置阈值，<code>threshold = len * 2 / 3</code></li></ol><ul><li><p><strong>set(ThreadLocal key, Object value)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//设置值</span><br><span class="line">private void set(ThreadLocal key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    //ThreadLocalMap使用Entry保存数据，获得保存所有Entry的数组（散列表）</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    //表的长度</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    根据ThreadLocal的哈希值计算散列位置</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">    //线性探测</span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">        //找到同样的键，直接覆盖值</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //键等于null，替换陈旧条目</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //映射位置没有元素，创建一个Entry初始化</span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    //清理一些插槽，如果没有清理，并且数组实际大小大于阈值，调用重新散列的方法</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>replaceStaleEntry(ThreadLocal key, Object value, int staleSlot)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//替换陈旧条目</span><br><span class="line">private void replaceStaleEntry(ThreadLocal key, Object value,</span><br><span class="line">                                       int staleSlot) &#123;</span><br><span class="line">    //取得散列表</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    int slotToExpunge = staleSlot;</span><br><span class="line">    // 优先往前查找要清除的插槽</span><br><span class="line">    for (int i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        if (e.get() == null)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    // 线性查找</span><br><span class="line">    for (int i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">        // 找到同样key，交换它们</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            // 未找到其他陈旧条目</span><br><span class="line">            if (slotToExpunge == staleSlot)</span><br><span class="line">            // 将当前位置记录为要清除的插槽</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            // 先expungeStaleEntry()清除要清除的插槽</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 没找到其他陈旧条目</span><br><span class="line">        if (k == null &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            // 记录原本陈旧条目位置为要清除的插槽</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前失效key没有被其他条目引用，创建一个条目放入插槽</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    tab[staleSlot] = new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    // 当找到其他陈旧条目时，清理陈旧条目</span><br><span class="line">    if (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>expungeStaleEntry(int staleSlot)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//删除陈旧条目</span><br><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line"></span><br><span class="line">    // 将陈旧条目所在插槽置null</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    tab[staleSlot] = null;</span><br><span class="line">    // 修改表条目数量</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    // 重新散列当前槽到下一个空槽间的条目位置</span><br><span class="line">    Entry e;</span><br><span class="line">    // 下一个空槽</span><br><span class="line">    int i;</span><br><span class="line">    for (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        // 陈旧条目直接删除</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            e.value = null;</span><br><span class="line">            tab[i] = null;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 重新计算散列位置</span><br><span class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">            // 新散列不等于当前位置</span><br><span class="line">            if (h != i) &#123;</span><br><span class="line">            // 清理当前位置</span><br><span class="line">                tab[i] = null;</span><br><span class="line"></span><br><span class="line">                // 新散列位置如果已被占用，往后散列（哈希冲突，开放定址法，线性探测）</span><br><span class="line">                while (tab[h] != null)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>rehash()</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//重新散列</span><br><span class="line">private void rehash() &#123;</span><br><span class="line">// 清理所有陈旧条目，循环调用了expungeStaleEntry()</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    // 扩容策略？当表已被使用阈值3/4时，调整表大小为原来的2倍</span><br><span class="line">    if (size &gt;= threshold - threshold / 4)</span><br><span class="line">    // 创建一个大小为原来2倍的数组</span><br><span class="line">    // 重新散列表中所有条目</span><br><span class="line">    // 重新计算阈值，替换旧表</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>getEntry(ThreadLocal key)</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>计算关键字的散列位置，根据散列位置取值Entry，找到正确Entry时，直接返回；反之调用直接取值失败的getEntry版本，该方法定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//直接取值失败的getEntry版本</span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    //不是空槽</span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        // 找到条目，返回（出口）</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        //失效条目，直接清除</span><br><span class="line">        if (k == null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        else</span><br><span class="line">        //线性探测</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>remove(ThreadLocal key)</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//删除</span><br><span class="line">private void remove(ThreadLocal key) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    //线性探测</span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        if (e.get() == key) &#123;</span><br><span class="line">        //断开ThreadLocal引用</span><br><span class="line">            e.clear();</span><br><span class="line">            //删除陈旧条目</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>ThreadLocal作用是提供线程的局部变量。</li><li>ThreadLocal中的threadLocalHashCode在类实例被创建时被确定，通过支持原子操作的数字类AtomicInteger来获得。</li><li>变量副本实际存放在ThreadLocal的静态内部类ThreadLocalMap中，该类也被作为线程Thread类的一个实例属性定义。</li><li>ThreadLocalMap是采用散列表来实现的，他是用开放定址法来解决哈希冲突。</li><li>ThreadLocalMap保存的是其静态内部类Entry的实例。通过ThreadLocal的实例属性threadLocalHashCode作为关键字通过一个算法来获得散列地址。</li><li>Entry类继承了WeakReference类，它对键保持的是一份弱引用。Entry使用ThreadLocal实例作为key，变量副本作为value。</li><li><note>cleanSomeSlots方法没看明白</note></li></ol></blockquote><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1><blockquote><p>参考博文：<a href="https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html" target="_blank" rel="noopener">【Java 并发】详解 ThreadLocal</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ThreadLocal 位于java.lang包下，用来为线程提供局部变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ThreadLocal用例&quot;&gt;&lt;a href=&quot;#ThreadLocal用例&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java" scheme="zzhangffan.com/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="zzhangffan.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>jdk及CGLib代理</title>
    <link href="zzhangffan.com/20180227/proxy/"/>
    <id>zzhangffan.com/20180227/proxy/</id>
    <published>2018-02-27T06:03:00.000Z</published>
    <updated>2018-03-02T03:42:42.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代理：为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>程序运行前就已经存在的编译好的代理类</p><p>假设我们有一个Hello类，其中有一个sayHello的方法，输出一个字符串，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line"></span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在要在sayHello方法执行前后做些事情，比如各打印一句话，我们可以将上面的程序改成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line"></span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;========== begin ==========&quot;);</span><br><span class="line">System.out.println(&quot;hello!&quot;);</span><br><span class="line">System.out.println(&quot;========== end ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看似完成了效果，但是需要我们修改sayHello方法的代码，有没有办法不修改目标方法呢，我们可以创建一个代理类，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class HelloProxy&#123;</span><br><span class="line"></span><br><span class="line">private Hello hello;</span><br><span class="line"></span><br><span class="line">public HelloProxy(Hello hello)&#123;</span><br><span class="line">this.hello = hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doProxy()&#123;</span><br><span class="line">System.out.println(&quot;========== begin ==========&quot;);</span><br><span class="line">hello.sayHello();</span><br><span class="line">System.out.println(&quot;========== end ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String [] args) &#123;</span><br><span class="line">HelloProxy proxy = new HelloProxy(new Hello());</span><br><span class="line">proxy.doProxy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，如果我们有多个类要实现同样的代理任务，按这种方式我们需要为每个类相应的创建一个XXXProxy代理类，看起来有点傻，有没有其他办法呢？我们可以用Java的动态代理来实现：</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>程序运行前并不存在代理类，无需手动编写代理类的源码<br><span class="note">Java动态代理需要代理类和委托类实现同一个接口,通过Java反射来生成。</span><br>定义一个目标接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface TargetInterface&#123;</span><br><span class="line"></span><br><span class="line">void sayHello();</span><br><span class="line">void sayGoodbye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现目标接口的委托类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TargetImpl implements TargetInterface&#123;</span><br><span class="line"></span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;========== hello ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sayGoodbye()&#123;</span><br><span class="line">System.out.println(&quot;========== goodbye ==========&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，代理处理类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">public ProxyHandler(Object target)&#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现了InvocationHandler接口，方法调用会被转发到这个方法</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;========== before ==========&quot;);</span><br><span class="line">Object object = method.invoke(target, args);</span><br><span class="line">System.out.println(&quot;========== after ==========&quot;);  </span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取代理类，*关键</span><br><span class="line">public &lt;T&gt; T getProxy()&#123;</span><br><span class="line">return (T) Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),//代理对象的类加载器</span><br><span class="line">target.getClass().getInterfaces(),//代理对象要实现的接口</span><br><span class="line">this);//实际处理程序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String [] args)&#123;</span><br><span class="line">TargetInterface target = new ProxyHandler(new TargetImpl()).getProxy();</span><br><span class="line">target.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译代理类后，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public final class $proxy4</span><br><span class="line">  extends Proxy</span><br><span class="line">  implements TargetInterface</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m0;</span><br><span class="line">  private static Method m4;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  </span><br><span class="line">  public $proxy4(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final void sayHello()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m3, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  public final void sayGoodbye()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m4, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //省略来自Object类的hashCode(),equals()以及toString()方法</span><br><span class="line">  </span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m3 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayHello&quot;, new Class[0]);</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      m4 = Class.forName(&quot;com.TargetInterface&quot;).getMethod(&quot;sayGoodbye&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面我们说过Java原生动态代理需要代理类和委托类实现同一接口，那如果是没有接口的类呢？<br>我们可以使用开源的CGLib。<br>用我们之前定义的Hello类，他没有实现任何接口，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理处理类：</p><ul><li>实现MethodInterceptor，方法调用转发到intercept()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyInterceptor implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;========== before ==========&quot;);</span><br><span class="line">Object object = proxy.invokeSuper(target,args);</span><br><span class="line">System.out.println(&quot;========== end ==========&quot;);</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getProxy(Class&lt;T&gt; cls)&#123;</span><br><span class="line">return (T) Enhancer.create(cls,this);//1 父类 2实际处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ProxyInterceptor proxy = new ProxyInterceptor();</span><br><span class="line">Hello hello = proxy.getProxy(Hello.class);</span><br><span class="line">hello.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类具体实现（来自网络）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class HelloConcrete$$EnhancerByCGLIB$$e3734e52</span><br><span class="line">  extends HelloConcrete</span><br><span class="line">  implements Factory</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  private MethodInterceptor CGLIB$CALLBACK_0; // ~~</span><br><span class="line">  ...</span><br><span class="line">   </span><br><span class="line">  public final String sayHello(String paramString)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0;</span><br><span class="line">    if (tmp17_14 != null) &#123;</span><br><span class="line">      // 将请求转发给MethodInterceptor.intercept()方法。</span><br><span class="line">      return (String)tmp17_14.intercept(this, </span><br><span class="line">              CGLIB$sayHello$0$Method, </span><br><span class="line">              new Object[] &#123; paramString &#125;, </span><br><span class="line">              CGLIB$sayHello$0$Proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.sayHello(paramString);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用jdk实现动态代理需要代理类和委托类实现同样的接口。</li><li>使用CGLib，用继承实现，不能对final修饰的类及方法使用。</li></ul><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;代理：为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;静态代理&quot;&gt;&lt;a href=&quot;#静态代理&quot; class=&quot;headerlink&quot; title=&quot;静态代理&quot;&gt;&lt;/a&gt;静态代理&lt;/h2&gt;&lt;p&gt;程
      
    
    </summary>
    
    
      <category term="Java" scheme="zzhangffan.com/tags/Java/"/>
    
      <category term="CGLib" scheme="zzhangffan.com/tags/CGLib/"/>
    
      <category term="Proxy" scheme="zzhangffan.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之ls</title>
    <link href="zzhangffan.com/20180111/linux-ls/"/>
    <id>zzhangffan.com/20180111/linux-ls/</id>
    <published>2018-01-11T02:19:41.000Z</published>
    <updated>2018-02-27T15:25:09.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此为Linux命令使用系列记录，博主使用到了哪些命令就写了哪些，命令的参数也记录不全，用到的就写了，需要完整学习，请参考<a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全(手册)_Linux常用命令行实例详解_Linux命令学习手册</a>    </p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>ls命令用来显示目标列表</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>ls  (选项)  (参数)</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>目录：指定要显示列表的目录，也可以是具体的文件。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li><p><strong><em>列出当前目录下非隐藏文件及目录</em></strong></p><blockquote><p>[root@hostname ~]#  ls</p></blockquote></li><li><p><strong><em>列出当前目录下所有文件及目录</em></strong></p><blockquote><p>[root@hostname ~]#  ls  -a<br>.   .bash_history  .bash_profile  .cache  .npm  .pydistutils.cfg  .tcshrc<br>..  .bash_logout   .bashrc        .cshrc  .pip  .ssh</p></blockquote></li><li><p><strong><em>以长格式列出当前目录下所有文件及目录</em></strong></p><blockquote><p>[root@hostname ~]# ls -a -l<br>total 60<br>dr-xr-x—.   6 root root  4096 Jan  1 09:57 .<br>dr-xr-xr-x.  18 root root  4096 Dec 31 14:45 ..<br>-rw——-    1 root root  1403 Jan 11 09:39 .bash_history<br>…</p></blockquote></li></ul><p>&emsp;&emsp;<a href="/post_sources/linuxcommands/ls-result.xml">命令结果解析</a></p><ul><li><p><strong><em>按最近一次修改的时间排序显示</em></strong></p><blockquote><p>[root@hostname ~]#  ls  -t<br>.bash_history  .     ..    .pydistutils.cfg  .bash_logout   .bashrc  .tcshrc<br>.npm           .ssh  .pip  .cache            .bash_profile  .cshrc</p></blockquote></li><li><p><strong><em>指定目录显示</em></strong></p><blockquote><p>[root@hostname tmp]#  ls  test<br>son  test.txt</p></blockquote></li><li><p><strong><em>遍历目录显示</em></strong></p><blockquote><p>[root@hostname tmp]#  ls  test -R<br>test:<br>son  test.txt<br>&emsp;<br>test/son:<br>sontest.txt</p></blockquote></li></ul><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a><strong>选项</strong></h2><blockquote><p>-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；<br>-A：显示除影藏文件“.”和“..”以外的所有文件列表；<br>-C：多列显示输出结果。这是默认选项；<br>-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；<br>-F：在每个输出项后追加文件的类型标识符，具体含义：“<em>”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；<br>-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；<br>-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；<br>-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；<br>-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；<br>-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；<br>–file-type：与“-F”选项的功能相同，但是不显示“</em>”；<br>-k：以KB（千字节）为单位显示文件大小；<br>-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；<br>-m：用“,”号区隔每个文件和目录的名称；<br>-n：以用户识别码和群组识别码替代其名称；<br>-r：以文件名反序排列并输出目录内容列表；<br>-s：显示文件和目录的大小，以区块为单位；<br>-t：用文件和目录的更改时间排序；<br>-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；<br>-R：递归处理，将指定目录下的所有文件及子目录一并处理；<br>–full-time：列出完整的日期与时间；<br>–color[=WHEN]：使用不同的颜色高亮显示不同类型的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;此为Linux命令使用系列记录，博主使用到了哪些命令就写了哪些，命令的参数也记录不全，用到的就写了，需要完整学习，请参考&lt;a href=&quot;http://man.linuxde.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="Linux" scheme="zzhangffan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub Pages搭建个人博客</title>
    <link href="zzhangffan.com/20171231/hexo-github-pages/"/>
    <id>zzhangffan.com/20171231/hexo-github-pages/</id>
    <published>2017-12-31T03:39:56.000Z</published>
    <updated>2018-02-27T15:37:47.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2></blockquote><ul><li>Node.js（必须）用于支持Hexo，生成静态页面</li><li>Git（必须）用于推送本地内容</li><li>注册一个GitHib账号，存放文件，服务器</li></ul><blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2></blockquote><ul><li><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><em>Node.js</em></h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><em>Windows</em></h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载.msi文件到本地，双击安装即可</p><h3 id="Linux-CentOS"><a href="#Linux-CentOS" class="headerlink" title="Linux(CentOS)"></a><em>Linux(CentOS)</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install nodejs</span><br></pre></td></tr></table></figure></li><li><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a><em>Git</em></h2><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a><em>Windows</em></h3><p><a href="https://git-scm.com/" target="_blank" rel="noopener">官网</a>下载安装软件包到本地，双击安装即可</p><h3 id="Linux-CentOS-1"><a href="#Linux-CentOS-1" class="headerlink" title="Linux(CentOS)"></a><em>Linux(CentOS)</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install git</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;<strong><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">教程：Git - Book</a></strong></p><ul><li><h2 id="GitHub（去注册）"><a href="#GitHub（去注册）" class="headerlink" title="GitHub（去注册）"></a><em>GitHub</em>（<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">去注册</a>）</h2><h3 id="关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可"><a href="#关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可" class="headerlink" title="关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可"></a>关联Git和GitHub，生成SSH密匙，输入下面命令后，一路回车即可</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;<strong><a href="https://github.com/settings/keys" target="_blank" rel="noopener">GitHub 配置SSH Key</a></strong></p><ul><li><h2 id="创建一个仓库做GitHub-Pages（What-is-GitHub-Pages-）"><a href="#创建一个仓库做GitHub-Pages（What-is-GitHub-Pages-）" class="headerlink" title="创建一个仓库做GitHub Pages（What is GitHub Pages?）"></a><em>创建一个仓库做GitHub Pages（<a href="https://help.github.com/articles/what-is-github-pages/" target="_blank" rel="noopener">What is GitHub Pages?</a>）</em></h2><h3 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h3>&emsp;&emsp;<span class="note"><em>1.第一次需要验证邮箱</em><br>&emsp;&emsp;<em>2.仓库名称固定格式为： 你的GitHub用户名.github.io</em></span><h3 id="创建成功后，现在可以访问你的GitHub-Pages了"><a href="#创建成功后，现在可以访问你的GitHub-Pages了" class="headerlink" title="创建成功后，现在可以访问你的GitHub Pages了"></a>创建成功后，现在可以访问你的GitHub Pages了</h3><img src="/images/hexo-github-pages/call-github-pages.png" alt="call-github-pages.png"></li></ul><blockquote><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/see-hexo-version.png" alt="see-hexo-version.png"></p><h3 id="创建Hexo目录"><a href="#创建Hexo目录" class="headerlink" title="创建Hexo目录"></a>创建Hexo目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir Hexo</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [目录名] 或进入目录执行命令 $ hexo init</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/hexo-init.png" alt="hexo-init.png"></p><h3 id="Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍）"><a href="#Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍）" class="headerlink" title="Hexo会自动在这个目录下建立需要的文件夹和文件（目录介绍）"></a>Hexo会自动在这个目录下建立需要的文件夹和文件（<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">目录介绍</a>）</h3><p><img src="/images/hexo-github-pages/hexo-dir.png" alt="hexo-dir.png"></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/npm-install.png" alt="npm-install.png"></p><blockquote><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2></blockquote><h3 id="生成静态页面和资源文件"><a href="#生成静态页面和资源文件" class="headerlink" title="生成静态页面和资源文件"></a>生成静态页面和资源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate简写：hexo g</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server简写：hexo s</span><br></pre></td></tr></table></figure><h3 id="命令可以组合使用-启动服务并生成资源文件"><a href="#命令可以组合使用-启动服务并生成资源文件" class="headerlink" title="命令可以组合使用,启动服务并生成资源文件"></a>命令可以组合使用,启动服务并生成资源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s -g</span><br></pre></td></tr></table></figure><p><strong><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">更多命令查看Hexo文档</a></strong></p><h3 id="现在你可以通过-http-localhost-4000-进行访问了"><a href="#现在你可以通过-http-localhost-4000-进行访问了" class="headerlink" title="现在你可以通过 http://localhost:4000/ 进行访问了"></a>现在你可以通过 <code>http://localhost:4000/</code> 进行访问了</h3><p><img src="/images/hexo-github-pages/hexo-index.png" alt="hexo-index.png"></p><blockquote><h2 id="部署至GitHub"><a href="#部署至GitHub" class="headerlink" title="部署至GitHub"></a>部署至GitHub</h2></blockquote><h3 id="修改Hexo根目录下的-config-yml-主站配置文件中的-deploy-参数："><a href="#修改Hexo根目录下的-config-yml-主站配置文件中的-deploy-参数：" class="headerlink" title="修改Hexo根目录下的 _config.yml 主站配置文件中的 deploy 参数："></a>修改Hexo根目录下的 <code>_config.yml</code> 主站配置文件中的 <code>deploy</code> 参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: &lt;仓库地址&gt;</span><br><span class="line">   branch: [分支名称]</span><br><span class="line">   message: [提交信息]</span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy 简写： hexo d</span><br></pre></td></tr></table></figure><p><img src="/images/hexo-github-pages/hexo-d.png" alt="hexo-d.png"></p><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>&emsp;&emsp;<span class="note"><em>部署提示找不到：git<br>&emsp;&emsp;3.0 后 type需改为 git ，deploy部分被单独出来了，需要单独安装</em></span></p><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="执行-hexo-d-，部署成功后开始访问你的博客吧！"><a href="#执行-hexo-d-，部署成功后开始访问你的博客吧！" class="headerlink" title="执行 hexo d ，部署成功后开始访问你的博客吧！"></a>执行 <code>hexo d</code> ，部署成功后开始访问你的博客吧！</h3><p><img src="/images/hexo-github-pages/github-pages-index.png" alt="github-pages-index.png"></p><h1 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h2 id=&quot;准备工具&quot;&gt;&lt;a href=&quot;#准备工具&quot; class=&quot;headerlink&quot; title=&quot;准备工具&quot;&gt;&lt;/a&gt;准备工具&lt;/h2&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Node.js（必须）用于支持Hexo，生成静态页面&lt;/l
      
    
    </summary>
    
    
      <category term="Hexo" scheme="zzhangffan.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
