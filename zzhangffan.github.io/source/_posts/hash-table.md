---
title: 哈希表
date: 2018-03-01 08:54:00
categoreies:
tags: Java
---
了解哈希表前先了解两个数据结构：
### 数组、链表 ###
* 数组
一组同类型元素的集合，在内存中表现为一片连续的空间，其中每个数据单元占用相等大小的内存空间。因为空间是连续的，所以可以通过地址的偏移（数组下标）来快速访问，但当要新增或删除一个元素时，其后所有元素要进行相应的移动。
![array](/images/hash-table/array.jpg)
>图片来自菜鸟教程

* 链表
是一种物理上非连续、非顺序的数据结构。由一系列节点组成，每个节点除了保存自己的数据还保存了一个指向后继节点的引用。这样每个节点就如同一个链子被串起来了。链表无法快速访问，当要访问一个元素的时候，需从链表的头节点开始遍历，直到找到对应的元素或到达链表尾。当修改或新增一个元素时，只需找到这个元素，并修改其相邻节点的相关引用即可。
![linked-list](/images/hash-table/linked-list.jpg)
>图片来自百度图片

## 哈希表 ##
哈希表也叫散列表，通过关键字映射到表中的一个位置来访问数据。映射关键字的函数叫散列函数，存放数据的数组叫散列表。
> 散列位置 = 散列函数(关键字)

### 散列函数常用设计方式 ###
1. 直接定址法
取关键字或关键字的某个线性函数值为散列地址。
2. 数字分析法
分析数据去除重复录较高的部分，利用差别比较大的部分来构建散列地址。
3. 平方取中法
取关键字平方后的中间几位来作为散列地址
4. 折叠法
将关键字分成位数相同的几部分，最后一部分可以不同，然后取这几部分的叠加和（舍去进位）作为散列地址。
5. 除留余数法
取关键字被某个不大于表长的数除运算后的余数作为散列地址。
> 散列地址 = 关键字 MOD 不大于表长的数
6. 随机算法
通过随机函数生成散列地址

一个好的散列函数的值应该尽可能平均分布。

### 散列冲突 ###
不管设计多好的散列函数，都可能出现不同的关键字被映射到表中的同一个位置，我们称着中情况为散列冲突。

假设我们的关键字是{47,67,56,16,25,22}，散列算法为` h(key) = key mod 6 ` 。当我们计算关键字{47,67,56,16}时都没有问题：
![eg](/images/hash-table/eg.jpg)

当散列关键字25时发现 25 mod 6 = 1，可索引1已经被占用了，这就出现了散列冲突。
解决冲突的方式：
#### 开放定址法（线性探测、二次探测、随机探测）####
开放定址法指的是当发生散列冲突时，去探测下一个空的散列位置，只要表中还存在空的散列地址，总能找到。
* 线性探测
在出现散列冲突的位置往后一个位置探测，直到遇到空的位置，存入数据。
例子中散列关键字25时索引位置1出现了冲突，我们往后一个位置探测，发现位置2也被占用了，继续往后探测，ok，索引3的位置为空，直接占下来。
![kfdz-xxtc1](/images/hash-table/kfdz-xxtc1.jpg)

* 二次探测
考虑一种情况，假设索引3在散列关键字25之前就被占用，表使用图示如下：
![kfdz-xxtc2](/images/hash-table/kfdz-xxtc2.jpg)
这种情况下，尽管表中还有可使用的位置，可通过线性探测我们将无法为关键字25找到可以散列的位置。
这种情况我们可以使用二次探测，它不只是往后探测，它对冲突位置前后都进行探测，如图示：
![kfdz-ectc](/images/hash-table/kfdz-ectc.jpg)

* 随机探测
通过一个伪随机函数（结果是可以确定的）生成散列地址。

开放定址可能出现非同义词的冲突。

#### 拉链法 ####
与开放地址寻找下一个空的散列地址不同，拉链法通过在原地进行处理，将所有同义词的记录存在一个单链表中，哈希表中值保存单链表的头指针。如图：
![llf](/images/hash-table/llf.jpg)

（完）
=====