---
title: 事务
date: 2018-03-03 14:09:58
categoreies:
tags:
---
## 什么是事务 ##
>事务，一般是指要做的或所做的事情。

## 数据库事务 ##
数据库事务，是指作为单个逻辑工作单元执行的一系列操作,要么完全地执行,要么完全地不执行。

事务的特性：
* 原子性（<note>基础</note>）
事务必须是一个不可分割的整体
* 一致性（<note>要求</note>）
事务（一组操作）完成时，必须让数据具有一致性。例如：你的朋友小明还钱给你，他从他的账上扣了1000，可你的账上并没有加1000块，你肯定认为这笔账没有还。这种情况就是非一致性的。
* 隔离性（<note>手段</note>）
数据库操作之间彼此应该是没有任何干扰的，假设你正在往数据库里查数据，别人正好在删数据，这种情况下你读的数据肯定是有问题的。
为了实现操作之间彼此没有干扰，有专家定义了一个规范（事务隔离级别）：
1. READ_UNCOMMITTED; 读未提交，一个事务可以读到另一个事务未提交的数据。
2. READ_COMMITTED; 读提交，一个事务要等另一个事务提交才能读数据。
3. REPEATABLE_READ; 重复读，一个事务开启时，其他事务不允许再做修改操作。
4. SERIALIZABLE; 序列化，事务串行化顺序执行。
* 持久性（<note>目的</note>）
事务一旦提交，数据库的修改应该永久的。还是还钱的例子，小明从他的账上扣了1000，你的账上也加了1000块，转账完成后，在不做其他数据库操作的情况下，这1000块钱应该永远存在你的账户。

## 事务面临的问题 ##
上面说事务的特性时，讲到的事务隔离级别就是为了解决下面的问题：
* 脏读（读到垃圾数据）
> 事务A从账户中转出1000元，事务B查询余额为0元，事务A刚才的转账事务，余额恢复为1000元，事务B往里存了1000元，并提交了事务。现在账户中余额为1000元，这肯定是不对的。

脏读：一个事务读到了另一个事务未提交的数据。通过设置数据库隔离级别为 TEAD_COMMITTED 解决。
* 不可重复读
> 事务A查询余额为1000元，事务B查询余额为1000元，事务A取出1000元并提交了事务，事务A再次查询余额，余额变成了0元。

不可重复读：一个事读了另一个事务已提交的更新操作。通过设置数据库级别为 REPEATABLE_READ 解决。
* 幻读
> 事务B查询班级人数为30人，事务A新增一个同学并提交事务，事务B再次统计人数为31元。事务B很懵逼，这怎么像鬼一样，突然就多出一个人来了。

幻读：一个事务读到另一个事务提交的新增操作。通过设置数据库级别为 SERIALIZABLE 解决。

<note>大多数数据库默认设置 READ_COMMITTED 为默认隔离级别，MySql默认使用 REPEATABLE-READ 为默认隔离级别。</note>

*********************************************************************
[数据库怎么实现隔离的？](https://www.cnblogs.com/wajika/p/6680200.html)

[Spirng事务支持](/20180303/spring-transcation-propagation-behavior/)

（完）
=====